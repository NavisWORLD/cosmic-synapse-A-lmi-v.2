<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>12D Cosmic Synapse - Audio-Driven Engine</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 50%, #2a1a4a 100%);
            color: #ffffff;
            overflow-x: hidden;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 30px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        h1 {
            font-size: 2.5em;
            background: linear-gradient(45deg, #00d4ff, #7b2ff7, #f06eaa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.1em;
            color: #a0a0ff;
            margin-bottom: 15px;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(123, 47, 247, 0.3);
        }

        .card h2 {
            color: #00d4ff;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .equation {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            margin: 10px 0;
            border-left: 3px solid #00d4ff;
            overflow-x: auto;
        }

        .value-display {
            background: rgba(123, 47, 247, 0.2);
            padding: 8px;
            border-radius: 8px;
            margin: 8px 0;
            font-size: 0.95em;
            border-left: 3px solid #7b2ff7;
        }

        #canvas-container {
            width: 100%;
            height: 500px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            margin: 20px 0;
            border: 2px solid rgba(0, 212, 255, 0.3);
            position: relative;
            overflow: hidden;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .control-group {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-group label {
            display: block;
            color: #00d4ff;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 0.9em;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(45deg, #00d4ff, #7b2ff7);
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(123, 47, 247, 0.5);
        }

        button {
            background: linear-gradient(45deg, #00d4ff, #7b2ff7);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
            margin: 5px;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(123, 47, 247, 0.5);
        }

        button:active {
            transform: scale(0.95);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .audio-controls {
            text-align: center;
            margin: 20px 0;
        }

        #micButton {
            background: linear-gradient(45deg, #ff0080, #ff8c00);
            font-size: 1.1em;
            padding: 15px 40px;
        }

        #micButton.active {
            background: linear-gradient(45deg, #00ff00, #00cc00);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 0, 0.5); }
            50% { box-shadow: 0 0 40px rgba(0, 255, 0, 0.8); }
        }

        .frequency-viz {
            width: 100%;
            height: 150px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin: 10px 0;
            position: relative;
        }

        #frequencyCanvas {
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .stat-box {
            background: rgba(0, 212, 255, 0.1);
            padding: 12px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(0, 212, 255, 0.3);
        }

        .stat-label {
            font-size: 0.8em;
            color: #a0a0ff;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.3em;
            font-weight: bold;
            color: #00d4ff;
        }

        .token-display {
            background: rgba(240, 110, 170, 0.1);
            border: 1px solid rgba(240, 110, 170, 0.3);
            border-radius: 10px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.75em;
        }

        .token-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            border-left: 3px solid #f06eaa;
            line-height: 1.5;
        }

        .token-item strong {
            color: #00d4ff;
        }

        .info-text {
            color: #b0b0ff;
            line-height: 1.5;
            margin: 8px 0;
            font-size: 0.9em;
        }

        .alert-box {
            background: rgba(123, 47, 247, 0.2);
            border-left: 4px solid #7b2ff7;
            padding: 12px;
            border-radius: 8px;
            margin: 15px 0;
            font-size: 0.95em;
        }

        #fps-counter {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 10;
            font-size: 0.9em;
        }

        .audio-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 0, 128, 0.7);
            padding: 8px 15px;
            border-radius: 5px;
            font-weight: bold;
            z-index: 10;
            display: none;
        }

        .audio-indicator.active {
            display: block;
            animation: blink 1s infinite;
        }

        .token-indicator {
            position: absolute;
            top: 50px;
            right: 10px;
            background: rgba(0, 212, 255, 0.7);
            padding: 8px 15px;
            border-radius: 5px;
            font-weight: bold;
            z-index: 10;
            display: none;
            font-size: 0.9em;
        }

        .token-indicator.active {
            display: block;
            animation: pulse-blue 0.5s infinite;
        }

        @keyframes pulse-blue {
            0%, 100% { 
                background: rgba(0, 212, 255, 0.7);
                box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
            }
            50% { 
                background: rgba(0, 255, 255, 0.9);
                box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
            }
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üé§ 12D Cosmic Synapse Theory</h1>
            <p class="subtitle">Audio-Driven Deterministic Cosmological Simulation Engine</p>
            <p class="info-text"><strong>CONTINUOUS TOKEN GENERATION:</strong> Audio ‚Üí FFT ‚Üí œÜ-Harmonics ‚Üí Sound-Color Mapping ‚Üí Seed Generation ‚Üí Token Stream</p>
            <p class="info-text" style="font-size: 0.85em; color: #7b2ff7;">Every audio frame generates multiple tokens through the 12D formula (œà = œÜE/c¬≤ + Œª + ‚à´v¬∑dt + Œ©E + U‚ÇÅ‚ÇÅD)</p>
        </header>

        <div class="audio-controls">
            <button id="micButton" onclick="toggleMicrophone()">üé§ START MICROPHONE ENGINE</button>
            <p class="info-text" style="margin-top: 10px;">
                <strong>Activate continuous token generation:</strong> Every 100ms, audio is analyzed and converted into:<br>
                ‚Ä¢ Audio Frame Tokens (complete spectrum snapshot)<br>
                ‚Ä¢ œÜ-Harmonic Tokens (golden ratio frequency series)<br>
                ‚Ä¢ Particle Creation/Update Tokens (visual entities)<br>
                ‚Ä¢ Sound‚ÜíColor‚ÜíSeed‚ÜíToken pipeline running in real-time
            </p>
        </div>

        <div class="grid">
            <div class="card">
                <h2>üéµ Audio Input Analysis</h2>
                <div class="frequency-viz">
                    <canvas id="frequencyCanvas"></canvas>
                </div>
                <div class="value-display">
                    RMS Energy: <span id="rms-energy">0.00</span>
                </div>
                <div class="value-display">
                    Dominant Freq: <span id="dominant-freq">0.0</span> Hz
                </div>
                <div class="value-display">
                    Spectral Centroid: <span id="spectral-centroid">0.0</span> Hz
                </div>
                <p class="info-text">Live FFT analysis of environmental sound</p>
            </div>

            <div class="card">
                <h2>‚ö° Mass-Energy (Audio-Modulated)</h2>
                <div class="equation">E = mc¬≤ (modulated by RMS)</div>
                <div class="value-display">
                    Base Energy: <span id="energy-value">8.99e16</span> J
                </div>
                <div class="value-display">
                    Audio Gain: <span id="audio-gain">1.00</span>x
                </div>
                <p class="info-text">Energy scaled by audio amplitude</p>
            </div>

            <div class="card">
                <h2>üåÄ œÜ-Harmonic Series</h2>
                <div class="equation">f_n = f‚ÇÄ ¬∑ œÜ^(n/2)</div>
                <div class="value-display">
                    œÜ = <span id="phi-value">1.618033988749895</span>
                </div>
                <div class="value-display">
                    Harmonics: <span id="harmonics-count">0</span> generated
                </div>
                <p class="info-text">Golden ratio frequency spacing</p>
            </div>

            <div class="card">
                <h2>ü¶ã Chaos & Butterfly Effect</h2>
                <div class="equation">Œª = lim (1/t) ln|dX(t)/dX(0)|</div>
                <div class="value-display">
                    Lyapunov: <span id="lyapunov-value">0.905</span>
                </div>
                <div class="value-display">
                    Audio Chaos: <span id="audio-chaos">0.00</span>
                </div>
                <p class="info-text">Chaos driven by frequency variance</p>
            </div>
        </div>

        <div class="card">
            <h2>üåä Lorenz Attractor - Audio-Reactive Visualization</h2>
            <div id="canvas-container">
                <div id="fps-counter">FPS: <span id="fps">60</span></div>
                <div class="audio-indicator" id="audioIndicator">üé§ LISTENING</div>
                <div class="token-indicator" id="tokenIndicator">üé´ GENERATING TOKENS</div>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <label>œÉ (Sigma): <span id="sigma-display">10</span></label>
                    <input type="range" id="sigma" min="1" max="20" value="10" step="0.1">
                </div>
                <div class="control-group">
                    <label>œÅ (Rho): <span id="rho-display">28</span></label>
                    <input type="range" id="rho" min="10" max="40" value="28" step="0.1">
                </div>
                <div class="control-group">
                    <label>Œ≤ (Beta): <span id="beta-display">2.667</span></label>
                    <input type="range" id="beta" min="1" max="5" value="2.667" step="0.01">
                </div>
                <div class="control-group">
                    <label>Audio Sensitivity: <span id="sensitivity-display">1.0</span></label>
                    <input type="range" id="sensitivity" min="0.1" max="5" value="1.0" step="0.1">
                </div>
                <div class="control-group">
                    <label>Replication Threshold: <span id="replication-display">50</span></label>
                    <input type="range" id="replication" min="10" max="200" value="50" step="10">
                </div>
            </div>

            <div style="text-align: center;">
                <button onclick="resetSystem()">üîÑ Reset</button>
                <button onclick="togglePause()">‚èØÔ∏è Pause/Play</button>
                <button onclick="changeColor()">üé® Color</button>
                <button onclick="addParticle()">‚ûï Add Particle</button>
            </div>
        </div>

        <!-- 12D CST Advanced Controls -->
        <div class="grid">
            <div class="card">
                <h2>‚öõÔ∏è Physics Controls</h2>
                <div class="controls">
                    <div class="control-group">
                        <label>Blend Lorenz: <span id="blend-lorenz-display">0.7</span></label>
                        <input type="range" id="blend-lorenz" min="0" max="1" value="0.7" step="0.05">
                        <small class="info-text">0=gravity only, 1=Lorenz only</small>
                    </div>
                    <div class="control-group">
                        <label>
                            <input type="checkbox" id="grav-enabled">
                            Enable Gravity
                        </label>
                    </div>
                    <div class="control-group">
                        <label>
                            <input type="checkbox" id="dm-enabled">
                            Enable Dark Matter
                        </label>
                    </div>
                    <div class="control-group">
                        <label>Cutoff Radius: <span id="rcutoff-display">10.0</span></label>
                        <input type="range" id="rcutoff" min="1" max="50" value="10.0" step="0.5">
                    </div>
                    <div class="control-group">
                        <label>Softening (Œµ): <span id="epsilon-display">0.1</span></label>
                        <input type="range" id="epsilon" min="0.01" max="1" value="0.1" step="0.01">
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>üß† Adaptive State Controls</h2>
                <div class="controls">
                    <div class="control-group">
                        <label>k (Coupling): <span id="k-display">0.5</span></label>
                        <input type="range" id="k" min="0" max="2" value="0.5" step="0.1">
                    </div>
                    <div class="control-group">
                        <label>Œ≥ (Decay): <span id="gamma-display">0.2</span></label>
                        <input type="range" id="gamma" min="0" max="1" value="0.2" step="0.05">
                    </div>
                    <div class="control-group">
                        <label>Œ± (Memory): <span id="alpha-display">0.3</span></label>
                        <input type="range" id="alpha" min="0" max="1" value="0.3" step="0.05">
                    </div>
                    <div class="control-group">
                        <label>œÉ (Similarity): <span id="sigma-sim-display">0.3</span></label>
                        <input type="range" id="sigma-sim" min="0.1" max="1" value="0.3" step="0.05">
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>üîÑ Synchronization & Timestep</h2>
                <div class="controls">
                    <div class="control-group">
                        <label>K_sync: <span id="ksync-display">0.1</span></label>
                        <input type="range" id="ksync" min="0" max="1" value="0.1" step="0.01">
                    </div>
                    <div class="control-group">
                        <label>Max dt: <span id="dtmax-display">0.01</span></label>
                        <input type="range" id="dtmax" min="0.001" max="0.1" value="0.01" step="0.001">
                    </div>
                    <div class="control-group">
                        <label>
                            <input type="checkbox" id="adaptive-dt" checked="true">
                            Adaptive Timestep
                        </label>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>üé¨ Determinism & Replay</h2>
                <div class="controls">
                    <div class="control-group">
                        <label>Seed: <input type="number" id="deterministic-seed" value="12345" style="width: 100px;"></label>
                        <button onclick="setDeterministicSeed(parseInt(document.getElementById('deterministic-seed').value))">Set Seed</button>
                    </div>
                    <div class="control-group">
                        <button onclick="toggleRecording()" id="record-btn">üî¥ Start Recording</button>
                        <button onclick="toggleReplay()" id="replay-btn">‚ñ∂Ô∏è Replay</button>
                    </div>
                    <div class="value-display" id="recording-status">Not recording</div>
                    </div>
                </div>
            </div>

        <!-- 12D CST Advanced Displays -->
        <div class="grid">
            <div class="card">
                <h2>üìä Conservation Diagnostics</h2>
                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-label">E_total</div>
                        <div class="stat-value" id="conservation-etotal">0.00</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">ŒîE/E‚ÇÄ</div>
                        <div class="stat-value" id="conservation-edrift">0.00%</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">|P|</div>
                        <div class="stat-value" id="conservation-pmag">0.00</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">|L|</div>
                        <div class="stat-value" id="conservation-lmag">0.00</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Virial</div>
                        <div class="stat-value" id="conservation-virial">1.00</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>üéµ Synchronization Metrics</h2>
                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-label">Order (r)</div>
                        <div class="stat-value" id="sync-r">0.00</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Mean Œ∏</div>
                        <div class="stat-value" id="sync-mean">0¬∞</div>
                    </div>
                </div>
                <p class="info-text">r=1: fully synchronized, r=0: no synchronization</p>
            </div>

            <div class="card">
                <h2>üåÄ œà Normalized Breakdown</h2>
                <div class="value-display">
                    <strong>Energy Term:</strong> <span id="psi-energy-term">0.000</span>
                </div>
                <div class="value-display">
                    <strong>Œª Term:</strong> <span id="psi-lambda-term">0.000</span>
                </div>
                <div class="value-display">
                    <strong>‚à´||v|| dt:</strong> <span id="psi-velint-term">0.000</span>
                </div>
                <div class="value-display">
                    <strong>‚à´|Œîx‚ÇÅ‚ÇÇ| dt:</strong> <span id="psi-x12int-term">0.000</span>
                </div>
                <div class="value-display">
                    <strong>Œ© Term:</strong> <span id="psi-omega-term">0.000</span>
                </div>
                <div class="value-display">
                    <strong>Potential Term:</strong> <span id="psi-potential-term">0.000</span>
                </div>
                <div class="value-display" style="border-left: 3px solid #00d4ff; font-weight: bold;">
                    <strong>Total œà:</strong> <span id="psi-total-normalized">0.000</span>
                </div>
            </div>

            <div class="card">
                <h2>üåå Dark Matter Parameters</h2>
                <div class="controls">
                    <div class="control-group">
                        <label>œÅ‚ÇÄ: <span id="dm-rho0-display">1.0</span></label>
                        <input type="range" id="dm-rho0" min="0.1" max="10" value="1.0" step="0.1">
                </div>
                    <div class="control-group">
                        <label>r_s: <span id="dm-rs-display">5.0</span></label>
                        <input type="range" id="dm-rs" min="1" max="20" value="5.0" step="0.5">
                </div>
                </div>
            </div>
        </div>

        <div class="grid">
            <div class="card">
                <h2>üéØ 12D State Function (œà)</h2>
                <div class="equation">
                    œà = œÜE/c¬≤ + Œª + ‚à´v¬∑dt + ‚à´Œîx‚ÇÅ‚ÇÇ¬∑dt + Œ©E + U‚ÇÅ‚ÇÅD
                </div>
                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-label">E/c¬≤</div>
                        <div class="stat-value" id="psi-energy">1.00</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">œÜ</div>
                        <div class="stat-value" id="psi-phi">1.618</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Œª</div>
                        <div class="stat-value" id="psi-lambda">0.905</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Œ©</div>
                        <div class="stat-value" id="psi-omega">12.45</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Total œà</div>
                        <div class="stat-value" id="psi-total">15.97</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>üé´ Continuous Token Stream</h2>
                <p class="info-text">
                    <strong>LIVE GENERATION:</strong> Audio Frame Tokens ‚Ä¢ œÜ-Harmonic Tokens ‚Ä¢ Particle Tokens ‚Ä¢ Frequency Update Tokens<br>
                    <em>Each audio snapshot creates deterministic, blockchain-ready tokens</em>
                </p>
                <div class="token-display" id="tokenDisplay">
                    <div class="token-item">Waiting for audio input...</div>
                </div>
                <div class="value-display">
                    Total Tokens: <span id="token-count">0</span>
                </div>
                <div style="text-align: center; margin-top: 10px;">
                    <button onclick="exportTokens()">üíæ Export Tokens (JSON)</button>
                    <button onclick="clearTokens()">üóëÔ∏è Clear Tokens</button>
                </div>
            </div>
        </div>

        <div class="alert-box">
            <strong>üî¨ System Status:</strong> <span id="system-status">Audio engine offline - Click START MICROPHONE to begin</span><br>
            <strong>üìä Particles:</strong> <span id="particle-count">0</span> active | 
            <strong>üé´ Tokens:</strong> <span id="token-count-status">0</span> generated |
            <strong>üîÑ Replications:</strong> <span id="replication-count">0</span> |
            <strong>‚ö° Token Rate:</strong> <span id="token-rate">0.0</span> tokens/sec
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        /*
         * ============================================================================
         * 12D COSMIC SYNAPSE THEORY - CONTINUOUS TOKEN GENERATION ENGINE v2.0
         * ============================================================================
         * 
         * UPGRADED FEATURES (v2.0):
         * 
         * 1. 11D-TO-3D PROJECTION: Each particle maintains 11D position/velocity projection
         * 2. GRAVITATIONAL SUBSTRATE: Softened Newtonian forces with optional dark matter (NFW profile)
         * 3. ADAPTIVE STATE x12: Per-particle 12th dimension with ODE evolution and memory m12
         * 4. SYNAPTIC STRENGTH Œ©: Gravitational coupling with Gaussian internal-state similarity
         * 5. CHARACTERISTIC FREQUENCY vi: Derived from cosmic energy (Ec/h) with phase synchronization
         * 6. KURAMOTO SYNCHRONIZATION: Phase coupling between particles with order parameter tracking
         * 7. ENTROPY: Coarse-grained Boltzmann-style entropy via speed histogram
         * 8. CONSERVATION DIAGNOSTICS: Energy, momentum, angular momentum tracking with virial checks
         * 9. SPATIAL INDEXING: Uniform grid for efficient neighbor queries (O(N) instead of O(N¬≤))
         * 10. ADAPTIVE TIMESTEP: Dynamic dt based on minimum distance and maximum velocity
         * 11. DETERMINISTIC REPLAY: Record audio frames and replay with fixed seed for reproducibility
         * 12. NORMALIZED œà: Dimensionless breakdown with reference scales (m0, Eref, tref, vref)
         * 
         * PIPELINE FLOW:
         * 1. AUDIO INPUT: Microphone captures live environmental sound (44.1kHz)
         * 2. FFT ANALYSIS: Fast Fourier Transform extracts frequency spectrum
         * 3. FREQUENCY EXTRACTION: Top 10 frequencies identified with magnitudes
         * 4. œÜ-HARMONIC GENERATION: Golden ratio (1.618...) creates harmonic series
         * 5. SOUND‚ÜíCOLOR MAPPING: Frequency (0-20kHz) mapped to Hue (0-360¬∞)
         * 6. SEED GENERATION: Deterministic seeds from frequency√ómagnitude combinations
         * 7. TOKEN CREATION: Every 100ms generates:
         *    - Audio Frame Tokens (complete spectrum snapshot)
         *    - œÜ-Harmonic Tokens (each harmonic in the series)
         *    - Particle Creation Tokens (new visual entities with x12, Ec, Œ©, vi, Œ∏, etc.)
         *    - Frequency Update Tokens (existing particle updates)
         * 8. œà CALCULATION: Normalized 12D state function: 
         *    œà = œÜ¬∑(Ec/Eref) + Œª + ‚à´||v|| dt/vref + ‚à´|Œîx12| dt + Œ©¬∑(Ec/Eref) + (Ugrav+Udm)/Eref
         * 9. PHYSICS INTEGRATION: Blended Lorenz + gravitational dynamics with adaptive states
         * 10. VISUAL RENDERING: Particles rendered in 3D with blended dynamics
         * 11. BLOCKCHAIN EXPORT: All tokens exportable as JSON for permanent record
         * 
         * CONTINUOUS: Token generation runs constantly while audio is active
         * DETERMINISTIC: Same audio input always produces identical tokens (replay mode)
         * 
         * REPLAY MODE USAGE:
         * 1. Click "Start Recording" to capture audio frames
         * 2. Set a deterministic seed (optional, defaults to 12345)
         * 3. Click "Replay" to feed recorded frames instead of live audio
         * 4. All tokens and œà values will be identical for the same recording
         * 
         * DEFAULT SETTINGS (tuned for stability):
         * - gravEnabled: false, dmEnabled: false, blendLorenz: 0.7
         * - adaptive timestep: true, k=0.5, Œ≥=0.2, Œ±=0.3, œÉ=0.3, Ksync=0.1
         * 
         * ============================================================================
         */
        
        // Constants
        const c = 299792458; // Speed of light
        const phi = (1 + Math.sqrt(5)) / 2;
        const h = 6.62607015e-34; // Planck's constant
        const kB = 1.380649e-23; // Boltzmann constant
        
        // Audio variables
        let audioContext = null;
        let analyser = null;
        let microphone = null;
        let dataArray = null;
        let bufferLength = 0;
        let isAudioActive = false;
        let frequencyData = [];
        let audioEnergy = 0;
        let spectralCentroid = 0;
        let tokenCount = 0;
        let tokens = [];
        let replicationThreshold = 50; // Energy threshold for particle replication
        let replicationCount = 0;
        let tokenGenerationRate = 0;
        let lastTokenCount = 0;
        let lastTokenTime = Date.now();
        let lastTokenRateTime = Date.now();

        // ============================================================================
        // 12D CST GLOBAL SIMULATION STATE
        // ============================================================================
        const physics = {
            G: 6.67430e-11, // Gravitational constant (m¬≥/kg/s¬≤)
            a0: 1.0, // Reference acceleration scale
            m0: 1.0, // Reference mass scale
            Eref: 1.0, // Reference energy scale
            tref: 1.0, // Reference time scale
            vref: 1.0, // Reference velocity scale
            epsilon: 0.1, // Softening parameter for gravity
            rCutoff: 10.0, // Cutoff radius for neighbor search
            blendLorenz: 0.7, // Blend factor: 0=gravity only, 1=Lorenz only
            gravEnabled: false, // Enable gravitational forces
            dmEnabled: false // Enable dark matter
        };

        const adapt = {
            k: 0.5, // Adaptive state coupling strength
            gamma: 0.2, // Adaptive state decay
            alpha: 0.3, // Memory update rate
            sigmaSimilarity: 0.3 // Gaussian width for similarity in Œ©
        };

        const sync = {
            Ksync: 0.1 // Kuramoto coupling strength
        };

        const timestep = {
            dt: 0.005, // Current timestep
            dtMax: 0.01, // Maximum timestep
            adaptive: true // Use adaptive timestep
        };

        const determinism = {
            mode: 'live', // 'live' or 'replay'
            seed: null, // Deterministic seed for replay
            recordedAudioFrames: [], // Recorded audio frames for replay
            isRecording: false, // Currently recording
            replayIndex: 0, // Current frame index in replay mode
            replayInterval: null // Interval ID for replay processing
        };
        
        // Accumulators for œà integrals
        const psiAccumulators = {
            velocityIntegral: new Map(), // ‚à´||v|| dt per particle
            x12Integral: new Map() // ‚à´|Œîx12| dt per particle
        };

        // Conservation tracking
        let conservationStats = {
            E0: 0, // Initial total energy
            P0: { x: 0, y: 0, z: 0 }, // Initial total momentum
            L0: { x: 0, y: 0, z: 0 }, // Initial total angular momentum
            lastUpdate: Date.now()
        };
        
        // Dark matter parameters
        const dmParams = {
            rho0: 1.0, // Central density
            rs: 5.0 // Scale radius
        };

        // UUID generator (deterministic in replay mode)
        function generateUUID() {
            if (determinism.mode === 'replay' && determinism.seed !== null) {
                // Use deterministic pseudo-random for replay
                determinism.seed = (determinism.seed * 1103515245 + 12345) & 0x7fffffff;
                const r = determinism.seed % 16;
                const v = r & 0x3 | 0x8;
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const val = c === 'x' ? r : v;
                    return val.toString(16);
                });
            }
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        
        // Deterministic random for replay mode
        let deterministicRandom = null;
        function getRandom() {
            if (determinism.mode === 'replay' && determinism.seed !== null) {
                if (!deterministicRandom) {
                    deterministicRandom = determinism.seed;
                }
                deterministicRandom = (deterministicRandom * 1103515245 + 12345) & 0x7fffffff;
                return (deterministicRandom / 0x7fffffff);
            }
            return Math.random();
        }
        
        function setDeterministicSeed(seed) {
            determinism.seed = seed;
            deterministicRandom = seed;
        }

        // Three.js setup
        let scene, camera, renderer;
        let particles = [];
        let isPaused = false;
        let colorHue = 180;
        let frameCount = 0;
        let lastTime = performance.now();

        // Lorenz parameters
        let sigma = 10;
        let rho = 28;
        let beta = 2.667;
        let audioSensitivity = 1.0;
        // Note: dt is now managed by timestep.dt (see timestep object above)

        // Frequency canvas
        let freqCanvas, freqCtx;

        class LorenzParticle {
            constructor(x, y, z, color, frequency = 0, parent = null) {
                this.id = generateUUID();
                this.x = x || 0.1;
                this.y = y || 0;
                this.z = z || 0;
                this.color = color || 0x00d4ff;
                this.frequency = frequency;
                this.energy = 0; // Legacy energy (kept for compatibility)
                this.mass = 1;
                this.velocity = { x: 0, y: 0, z: 0 };
                this.entropy = 0; // Legacy entropy
                this.memory = new Array(10).fill(0);
                this.tokens = []; // Token list per particle
                this.parent = parent; // Track parent for replication
                this.points = [];
                this.maxPoints = 2000;
                this.createdAt = Date.now();
                
                // ============================================================================
                // 12D CST NEW PROPERTIES
                // ============================================================================
                this.x12 = 0; // Adaptive state (dimensionless, bounded [-1, 1])
                this.m12 = 0; // Memory of x12
                this.Ec = 0; // Cosmic energy = kinetic + potential + dark matter
                this.Ugrav = 0; // Gravitational potential energy
                this.Udm = 0; // Dark matter potential contribution
                this.vi = 0; // Characteristic frequency = Ec/h
                this.theta = getRandom() * 2 * Math.PI; // Phase (initialized randomly)
                this.neighbors = []; // Cached neighbor indices
                this.omega = 0; // Œ©i = synaptic strength
                this.entropyS = 0; // Boltzmann-style coarse-grained entropy
                this.projection11D = {
                    pos11D: new Float64Array(11).fill(0),
                    vel11D: new Float64Array(11).fill(0)
                };
                
                // Initialize 11D projection (project 3D position to 11D)
                this.update11DProjection();
                
                // Create line geometry
                const geometry = new THREE.BufferGeometry();
                const material = new THREE.LineBasicMaterial({ 
                    color: this.color,
                    transparent: true,
                    opacity: 0.7
                });
                this.line = new THREE.Line(geometry, material);
                scene.add(this.line);
                
                // Add starting glow sphere
                const sphereGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const sphereMaterial = new THREE.MeshBasicMaterial({ 
                    color: this.color,
                    transparent: true,
                    opacity: 0.8
                });
                this.sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                scene.add(this.sphere);
            }

            // Update 11D projection from 3D position
            update11DProjection() {
                // Simple projection: replicate x,y,z with variations
                const scale = 0.1;
                for (let i = 0; i < 11; i++) {
                    const dim = i % 3;
                    const coord = dim === 0 ? this.x : (dim === 1 ? this.y : this.z);
                    this.projection11D.pos11D[i] = coord * (1 + i * scale);
                    this.projection11D.vel11D[i] = (dim === 0 ? this.velocity.x : (dim === 1 ? this.velocity.y : this.velocity.z)) * (1 + i * scale);
                }
            }

            update(audioModulation = 1.0, gravAcceleration = null) {
                // Audio-modulated Lorenz equations
                const effectiveSigma = sigma * (1 + audioModulation * 0.5);
                const effectiveRho = rho * (1 + audioModulation * 0.3);
                
                const dxLorenz = effectiveSigma * (this.y - this.x) * timestep.dt;
                const dyLorenz = (this.x * (effectiveRho - this.z) - this.y) * timestep.dt;
                const dzLorenz = (this.x * this.y - beta * this.z) * timestep.dt;

                // Blend Lorenz and gravitational accelerations
                let dx, dy, dz;
                if (gravAcceleration && physics.gravEnabled) {
                    const dxGrav = gravAcceleration.x * timestep.dt;
                    const dyGrav = gravAcceleration.y * timestep.dt;
                    const dzGrav = gravAcceleration.z * timestep.dt;
                    
                    dx = physics.blendLorenz * dxLorenz + (1 - physics.blendLorenz) * dxGrav;
                    dy = physics.blendLorenz * dyLorenz + (1 - physics.blendLorenz) * dyGrav;
                    dz = physics.blendLorenz * dzLorenz + (1 - physics.blendLorenz) * dzGrav;
                } else {
                    dx = dxLorenz;
                    dy = dyLorenz;
                    dz = dzLorenz;
                }

                this.x += dx;
                this.y += dy;
                this.z += dz;

                // Update velocity
                this.velocity = { x: dx / timestep.dt, y: dy / timestep.dt, z: dz / timestep.dt };
                
                // Update 11D projection
                this.update11DProjection();

                // Store point
                this.points.push(new THREE.Vector3(this.x, this.y, this.z));
                
                if (this.points.length > this.maxPoints) {
                    this.points.shift();
                }

                // Update geometry
                const positions = new Float32Array(this.points.length * 3);
                for (let i = 0; i < this.points.length; i++) {
                    positions[i * 3] = this.points[i].x;
                    positions[i * 3 + 1] = this.points[i].y;
                    positions[i * 3 + 2] = this.points[i].z;
                }
                
                this.line.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.line.geometry.attributes.position.needsUpdate = true;

                // Update sphere position
                this.sphere.position.set(this.x, this.y, this.z);

                // Calculate cosmic energy: Ec = 0.5 * m * v^2 * c^2 (relativistic-inspired)
                const velocityMagnitude = Math.sqrt(dx*dx + dy*dy + dz*dz) / timestep.dt;
                this.energy = 0.5 * this.mass * velocityMagnitude * velocityMagnitude;
                
                // Update entropy based on trajectory complexity
                this.entropy = Math.log(this.points.length + 1) * this.energy;

                // Check for replication
                this.checkReplication();

                return { dx, dy, dz };
            }

            checkReplication() {
                // Replication when Ec and omega exceed thresholds
                const energyThreshold = this.Ec > replicationThreshold;
                const omegaThreshold = this.omega > 0.1; // Minimum synaptic strength
                
                if (energyThreshold && omegaThreshold && particles.length < 30) {
                    // Create offspring particle
                    const offset = (getRandom() * 2 - 1) * 0.5;
                    const color = new THREE.Color(this.color);
                    color.offsetHSL(0.1, 0, 0); // Slight color variation
                    
                    const offspring = new LorenzParticle(
                        this.x + offset,
                        this.y + offset,
                        this.z + offset,
                        color.getHex(),
                        this.frequency * (1 + (getRandom() * 0.1 - 0.05)), // Slight frequency mutation
                        this.id // Set parent
                    );
                    
                    offspring.mass = this.mass * (0.95 + getRandom() * 0.1);
                    offspring.x12 = this.x12 + (getRandom() * 0.2 - 0.1); // Inherit with variation
                    offspring.m12 = this.m12;
                    
                    // Split energy
                    this.Ec *= 0.5;
                    offspring.Ec = this.Ec;
                    this.energy *= 0.5; // Legacy
                    offspring.energy = this.energy;
                    
                    particles.push(offspring);
                    replicationCount++;
            
                    // Generate replication token for offspring
                    generateParticleToken(offspring, 'replication');
                    
                    updateStatus(`Particle ${this.id.substr(0, 8)} replicated ‚Üí ${offspring.id.substr(0, 8)}`);
                }
            }

            assignFrequency(freq, magnitude) {
                this.frequency = freq;
                // Generate simple token format for frequency assignment
                const simpleToken = `Freq_${freq.toFixed(2)}_Particle_${this.id.substr(0, 8)}`;
                this.tokens.push(simpleToken);
            }

            destroy() {
                scene.remove(this.line);
                scene.remove(this.sphere);
                this.line.geometry.dispose();
                this.line.material.dispose();
                this.sphere.geometry.dispose();
                this.sphere.material.dispose();
            }
        }

        // ============================================================================
        // 12D CST CORE ALGORITHMS
        // ============================================================================
        
        // 1) Spatial indexing for neighbor queries
        function buildSpatialIndex(particles, rCutoff) {
            // Simple uniform grid spatial index (3D)
            const cellSize = rCutoff;
            const grid = new Map();
            
            particles.forEach((p, i) => {
                const gx = Math.floor(p.x / cellSize);
                const gy = Math.floor(p.y / cellSize);
                const gz = Math.floor(p.z / cellSize);
                const key = `${gx},${gy},${gz}`;
                
                if (!grid.has(key)) {
                    grid.set(key, []);
                }
                grid.get(key).push(i);
            });
            
            return { grid, cellSize };
        }

        function queryNeighbors(i, particles, index, rCutoff) {
            const p = particles[i];
            const neighbors = [];
            const cellSize = index.cellSize;
            
            // Check current cell and 26 neighboring cells
            const gx = Math.floor(p.x / cellSize);
            const gy = Math.floor(p.y / cellSize);
            const gz = Math.floor(p.z / cellSize);
            
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        const key = `${gx + dx},${gy + dy},${gz + dz}`;
                        const cell = index.grid.get(key);
                        if (cell) {
                            cell.forEach(j => {
                                if (i !== j) {
                                    const pj = particles[j];
                                    const dx2 = pj.x - p.x;
                                    const dy2 = pj.y - p.y;
                                    const dz2 = pj.z - p.z;
                                    const r = Math.sqrt(dx2*dx2 + dy2*dy2 + dz2*dz2);
                                    if (r <= rCutoff) {
                                        neighbors.push(j);
                                    }
                                }
                            });
                        }
                    }
                }
            }
            
            return neighbors;
        }

        // 2) Gravitational forces and energies
        function computeGravitationalAccelerations(particles, index, physics) {
            const accelerations = particles.map(() => ({ x: 0, y: 0, z: 0 }));
            
            if (!physics.gravEnabled) return accelerations;
            
            particles.forEach((pi, i) => {
                const neighbors = queryNeighbors(i, particles, index, physics.rCutoff);
                
                neighbors.forEach(j => {
                    const pj = particles[j];
                    const dx = pj.x - pi.x;
                    const dy = pj.y - pi.y;
                    const dz = pj.z - pi.z;
                    const r2 = dx*dx + dy*dy + dz*dz;
                    const r_eff2 = r2 + physics.epsilon * physics.epsilon;
                    const r_eff = Math.sqrt(r_eff2);
                    
                    const force = physics.G * pi.mass * pj.mass / r_eff2;
                    const fx = force * (dx / r_eff);
                    const fy = force * (dy / r_eff);
                    const fz = force * (dz / r_eff);
                    
                    accelerations[i].x += fx / pi.mass;
                    accelerations[i].y += fy / pi.mass;
                    accelerations[i].z += fz / pi.mass;
                });
            });
            
            return accelerations;
        }

        function computeGravitationalEnergy(particles, index, physics) {
            if (!physics.gravEnabled) {
                particles.forEach(p => p.Ugrav = 0);
                return;
            }
            
            particles.forEach((pi, i) => {
                let U = 0;
                const neighbors = queryNeighbors(i, particles, index, physics.rCutoff);
                
                neighbors.forEach(j => {
                    const pj = particles[j];
                    const dx = pj.x - pi.x;
                    const dy = pj.y - pi.y;
                    const dz = pj.z - pi.z;
                    const r2 = dx*dx + dy*dy + dz*dz;
                    const r_eff = Math.sqrt(r2 + physics.epsilon * physics.epsilon);
                    
                    U -= physics.G * pi.mass * pj.mass / r_eff;
                });
                
                pi.Ugrav = U;
            });
        }

        // 3) Dark matter via NFW profile
        function computeDarkMatterPotential(particles, dmParams) {
            if (!physics.dmEnabled) {
                particles.forEach(p => p.Udm = 0);
                return;
            }
            
            particles.forEach(p => {
                const r = Math.sqrt(p.x*p.x + p.y*p.y + p.z*p.z);
                const r_rs = r / dmParams.rs;
                
                // NFW density profile: œÅ(r) = œÅ0 / ((r/rs) * (1 + r/rs)^2)
                const rho = dmParams.rho0 / (r_rs * Math.pow(1 + r_rs, 2));
                
                // Simplified potential: Udm = -G * m * œÅ * 4œÄ * r^2 / 3
                p.Udm = -physics.G * p.mass * rho * 4 * Math.PI * r * r / 3;
            });
        }

        // 4) Synaptic strength Œ© with similarity
        function computeSynapticStrength(particles, index, physics, adapt) {
            particles.forEach((pi, i) => {
                let omegaSum = 0;
                const neighbors = queryNeighbors(i, particles, index, physics.rCutoff);
                pi.neighbors = neighbors;
                
                neighbors.forEach(j => {
                    const pj = particles[j];
                    const dx = pj.x - pi.x;
                    const dy = pj.y - pi.y;
                    const dz = pj.z - pi.z;
                    const r2 = dx*dx + dy*dy + dz*dz;
                    const r_eff2 = r2 + physics.epsilon * physics.epsilon;
                    
                    // Gravitational coupling term
                    const gravTerm = (physics.G * pi.mass * pj.mass) / (r_eff2 * physics.a0 * physics.m0);
                    
                    // Gaussian similarity term
                    const x12Diff = pi.x12 - pj.x12;
                    const similarity = Math.exp(-(x12Diff * x12Diff) / (2 * adapt.sigmaSimilarity * adapt.sigmaSimilarity));
                    
                    omegaSum += gravTerm * similarity;
                });
                
                pi.omega = omegaSum;
            });
        }

        // 5) 12th dimension evolution and memory
        function updateAdaptiveStates(particles, adapt, dt) {
            particles.forEach(p => {
                // dx12/dt = k * Œ©i ‚àí Œ≥ * x12_i
                const dx12 = (adapt.k * p.omega - adapt.gamma * p.x12) * dt;
                p.x12 += dx12;
                
                // Bound x12 to [-1, 1]
                p.x12 = Math.max(-1, Math.min(1, p.x12));
                
                // dm12/dt = Œ± * (x12_i ‚àí m12_i)
                const dm12 = adapt.alpha * (p.x12 - p.m12) * dt;
                p.m12 += dm12;
            });
        }

        // 6) Characteristic frequency and phase synchronization
        function updatePhases(particles, sync, index, dt) {
            particles.forEach((pi, i) => {
                // vi = Ec / h
                pi.vi = pi.Ec / h;
                
                // Kuramoto phase dynamics
                let phaseCoupling = 0;
                const neighbors = pi.neighbors || queryNeighbors(i, particles, index, physics.rCutoff);
                const degree = Math.max(1, neighbors.length);
                
                neighbors.forEach(j => {
                    const pj = particles[j];
                    phaseCoupling += Math.sin(pj.theta - pi.theta);
                });
                
                // dŒ∏i/dt = vi + (Ksync / deg_i) Œ£_j sin(Œ∏j ‚àí Œ∏i)
                const dtheta = (pi.vi + (sync.Ksync / degree) * phaseCoupling) * dt;
                pi.theta += dtheta;
                
                // Keep theta in [0, 2œÄ]
                pi.theta = ((pi.theta % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
            });
        }

        function computeSynchronizationMetric(particles) {
            if (particles.length === 0) return { r: 0, meanTheta: 0 };
            
            let sumReal = 0;
            let sumImag = 0;
            
            particles.forEach(p => {
                sumReal += Math.cos(p.theta);
                sumImag += Math.sin(p.theta);
            });
            
            const r = Math.sqrt(sumReal*sumReal + sumImag*sumImag) / particles.length;
            const meanTheta = Math.atan2(sumImag, sumReal);
            
            return { r, meanTheta };
        }

        // 7) Entropy via coarse-graining
        function computeEntropy(particles, kB, bins = 32) {
            if (particles.length === 0) return 0;
            
            // Bin particle speeds
            const speeds = particles.map(p => {
                const v = Math.sqrt(p.velocity.x*p.velocity.x + p.velocity.y*p.velocity.y + p.velocity.z*p.velocity.z);
                return v;
            });
            
            const maxSpeed = Math.max(...speeds, 1);
            const histogram = new Array(bins).fill(0);
            
            speeds.forEach(v => {
                const bin = Math.min(bins - 1, Math.floor((v / maxSpeed) * bins));
                histogram[bin]++;
            });
            
            // Shannon entropy: S = -kB Œ£ p_b ln p_b
            let S = 0;
            histogram.forEach(count => {
                if (count > 0) {
                    const p = count / particles.length;
                    S -= p * Math.log(p);
                }
            });
            
            const entropy = kB * S;
            
            // Update per-particle entropy (use global for now)
            particles.forEach(p => {
                p.entropyS = entropy;
            });
            
            return entropy;
        }

        // 8) Energy and conservation diagnostics
        function computeConservationStats(particles) {
            let Etotal = 0;
            const P = { x: 0, y: 0, z: 0 };
            const L = { x: 0, y: 0, z: 0 };
            
            particles.forEach(p => {
                // Kinetic energy
                const v2 = p.velocity.x*p.velocity.x + p.velocity.y*p.velocity.y + p.velocity.z*p.velocity.z;
                const K = 0.5 * p.mass * v2;
                
                // Cosmic energy: Ec = K + Ugrav + Udm
                p.Ec = K + p.Ugrav + p.Udm;
                Etotal += p.Ec;
                
                // Momentum
                P.x += p.mass * p.velocity.x;
                P.y += p.mass * p.velocity.y;
                P.z += p.mass * p.velocity.z;
                
                // Angular momentum: L = r √ó (m v)
                L.x += p.mass * (p.y * p.velocity.z - p.z * p.velocity.y);
                L.y += p.mass * (p.z * p.velocity.x - p.x * p.velocity.z);
                L.z += p.mass * (p.x * p.velocity.y - p.y * p.velocity.x);
            });
            
            // Compute drift
            const now = Date.now();
            const timeDiff = (now - conservationStats.lastUpdate) / 1000;
            let drift = { E: 0, P: 0, L: 0 };
            
            if (conservationStats.E0 !== 0 && timeDiff > 0) {
                drift.E = Math.abs((Etotal - conservationStats.E0) / conservationStats.E0);
                const P0mag = Math.sqrt(conservationStats.P0.x**2 + conservationStats.P0.y**2 + conservationStats.P0.z**2);
                const Pmag = Math.sqrt(P.x**2 + P.y**2 + P.z**2);
                if (P0mag > 0) {
                    drift.P = Math.abs((Pmag - P0mag) / P0mag);
                }
                const L0mag = Math.sqrt(conservationStats.L0.x**2 + conservationStats.L0.y**2 + conservationStats.L0.z**2);
                const Lmag = Math.sqrt(L.x**2 + L.y**2 + L.z**2);
                if (L0mag > 0) {
                    drift.L = Math.abs((Lmag - L0mag) / L0mag);
        }
            }
            
            return { Etotal, P, L, drift };
        }
        
        function checkVirial(particles) {
            let Ksum = 0;
            let Usum = 0;
            
            particles.forEach(p => {
                const v2 = p.velocity.x*p.velocity.x + p.velocity.y*p.velocity.y + p.velocity.z*p.velocity.z;
                Ksum += 0.5 * p.mass * v2;
                Usum += p.Ugrav + p.Udm;
            });
            
            // Virial: 2<K> ‚âà -<U>
            const ratio = Math.abs(Usum) > 1e-10 ? (2 * Ksum) / Math.abs(Usum) : 1;
            const ok = Math.abs(ratio - 1) < 0.1; // Within 10% tolerance
            
            return { ratio, ok };
        }

        // 9) œà normalization and breakdown
        function updatePsiNormalized(particles, refs, accum) {
            const terms = {
                energyTerm: 0,
                lambdaTerm: 0,
                velocityIntegralTerm: 0,
                x12IntegralTerm: 0,
                omegaTerm: 0,
                potentialTerm: 0
            };
            
            if (particles.length === 0) {
                return { terms, psiTotal: 0 };
            }
            
            particles.forEach((p, i) => {
                // Update velocity integral accumulator
                const vMag = Math.sqrt(p.velocity.x*p.velocity.x + p.velocity.y*p.velocity.y + p.velocity.z*p.velocity.z);
                const vInt = (accum.velocityIntegral.get(i) || 0) + (vMag / refs.vref) * timestep.dt;
                accum.velocityIntegral.set(i, vInt);
                
                // Update x12 integral accumulator
                const x12Int = (accum.x12Integral.get(i) || 0) + Math.abs(p.x12) * timestep.dt;
                accum.x12Integral.set(i, x12Int);
                
                // Compute terms
                terms.energyTerm += phi * (p.Ec / refs.Eref);
                terms.lambdaTerm += Math.log(Math.abs(vMag) + 1) / 100; // Simplified Œª
                terms.velocityIntegralTerm += vInt;
                terms.x12IntegralTerm += x12Int;
                terms.omegaTerm += p.omega * (p.Ec / refs.Eref);
                terms.potentialTerm += (p.Ugrav + p.Udm) / refs.Eref;
            });
            
            const psiTotal = terms.energyTerm + terms.lambdaTerm + terms.velocityIntegralTerm + 
                           terms.x12IntegralTerm + terms.omegaTerm + terms.potentialTerm;
            
            return { terms, psiTotal };
        }

        // 10) Adaptive timestep
        function computeAdaptiveDt(particles, physics, timestepConfig) {
            if (!timestepConfig.adaptive || particles.length === 0) {
                return timestepConfig.dt;
            }
            
            let rMin = Infinity;
            let vMax = 0;
            
            particles.forEach(p => {
                const v = Math.sqrt(p.velocity.x*p.velocity.x + p.velocity.y*p.velocity.y + p.velocity.z*p.velocity.z);
                vMax = Math.max(vMax, v);
                
                // Find minimum distance to neighbors
                const neighbors = p.neighbors || [];
                neighbors.forEach(j => {
                    const pj = particles[j];
                    const dx = pj.x - p.x;
                    const dy = pj.y - p.y;
                    const dz = pj.z - p.z;
                    const r = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        rMin = Math.min(rMin, r);
                });
            });
            
            if (rMin === Infinity) rMin = 1.0;
            if (vMax === 0) vMax = 1.0;
            
            // dt = min(dtMax, 0.1 * r_min / v_max)
            const dt = Math.min(timestepConfig.dtMax, 0.1 * rMin / vMax);
            return Math.max(dt, 0.001); // Minimum timestep
        }

        // 11) Deterministic replay mode
        function recordAudioFrame(frame) {
            if (determinism.isRecording) {
                determinism.recordedAudioFrames.push({
                    timestamp: Date.now() / 1000,
                    rmsEnergy: frame.rmsEnergy,
                    frequencyData: frame.frequencyData,
                    spectralCentroid: frame.spectralCentroid,
                    harmonics: frame.harmonics
                });
            }
        }

        function toggleReplayMode(data) {
            if (data && data.recordedAudioFrames) {
                determinism.mode = 'replay';
                determinism.recordedAudioFrames = data.recordedAudioFrames;
                determinism.replayIndex = 0;
                if (data.seed) {
                    setDeterministicSeed(data.seed);
                }
                // Start replay processing
                startReplayProcessing();
            } else {
                determinism.mode = 'live';
                determinism.recordedAudioFrames = [];
                stopReplayProcessing();
            }
        }

        // Process recorded audio frames in replay mode
        function processReplayAudio() {
            if (determinism.mode !== 'replay' || determinism.recordedAudioFrames.length === 0) {
                stopReplayProcessing();
                return;
            }

            // Get current frame
            const frame = determinism.recordedAudioFrames[determinism.replayIndex];
            if (!frame) {
                // Loop back to start
                determinism.replayIndex = 0;
                return;
            }

            // Update global audio state from recorded frame
            audioEnergy = frame.rmsEnergy || 0;
            frequencyData = frame.frequencyData || [];
            spectralCentroid = frame.spectralCentroid || 0;

            // Update displays
            const rmsEl = document.getElementById('rms-energy');
            const dominantEl = document.getElementById('dominant-freq');
            const centroidEl = document.getElementById('spectral-centroid');
            const gainEl = document.getElementById('audio-gain');
            
            if (rmsEl) rmsEl.textContent = audioEnergy.toFixed(3);
            if (gainEl) gainEl.textContent = (1 + audioEnergy * audioSensitivity).toFixed(2);
            if (frequencyData.length > 0 && dominantEl) {
                dominantEl.textContent = frequencyData[0].frequency.toFixed(1);
            }
            if (centroidEl) centroidEl.textContent = spectralCentroid.toFixed(1);

            // Generate tokens from recorded frame
            generateTokens(frequencyData, audioEnergy, spectralCentroid);

            // Update chaos measure
            const chaos = calculateAudioChaos();
            const chaosEl = document.getElementById('audio-chaos');
            if (chaosEl) chaosEl.textContent = chaos.toFixed(3);

            // Move to next frame
            determinism.replayIndex = (determinism.replayIndex + 1) % determinism.recordedAudioFrames.length;
        }

        function startReplayProcessing() {
            stopReplayProcessing(); // Clear any existing interval
            if (determinism.mode === 'replay' && determinism.recordedAudioFrames.length > 0) {
                // Process immediately, then every 100ms
                processReplayAudio();
                determinism.replayInterval = setInterval(processReplayAudio, 100);
            }
        }

        function stopReplayProcessing() {
            if (determinism.replayInterval) {
                clearInterval(determinism.replayInterval);
                determinism.replayInterval = null;
            }
        }

        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0a0a1a, 0.002);
            
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(50, 30, 50);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setClearColor(0x0a0a1a, 0.5);
            container.appendChild(renderer.domElement);

            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0x00d4ff, 1, 100);
            pointLight.position.set(0, 0, 0);
            scene.add(pointLight);

            // Add initial particle
            addParticle();

            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
        }

        function initFrequencyCanvas() {
            freqCanvas = document.getElementById('frequencyCanvas');
            if (freqCanvas) {
            freqCtx = freqCanvas.getContext('2d');
                freqCanvas.width = freqCanvas.offsetWidth || 400;
                freqCanvas.height = freqCanvas.offsetHeight || 150;
                
                // Handle window resize for frequency canvas
                window.addEventListener('resize', () => {
                    if (freqCanvas) {
                        freqCanvas.width = freqCanvas.offsetWidth || 400;
                        freqCanvas.height = freqCanvas.offsetHeight || 150;
                    }
                });
            }
        }

        async function toggleMicrophone() {
            const button = document.getElementById('micButton');
            const indicator = document.getElementById('audioIndicator');
            
            if (!isAudioActive) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 2048;
                    bufferLength = analyser.frequencyBinCount;
                    dataArray = new Uint8Array(bufferLength);

                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    microphone = audioContext.createMediaStreamSource(stream);
                    microphone.connect(analyser);

                    isAudioActive = true;
                    button.textContent = 'üé§ STOP MICROPHONE';
                    button.classList.add('active');
                    indicator.classList.add('active');
                    updateStatus('üéµ Audio engine active - CONTINUOUSLY generating tokens from audio stream');
                    
                    processAudio();
                } catch (err) {
                    console.error('Microphone access error:', err);
                    alert('Could not access microphone. Please grant permission.');
                }
            } else {
                if (microphone) {
                    microphone.disconnect();
                    microphone = null;
                }
                if (audioContext) {
                    audioContext.close();
                    audioContext = null;
                }
                isAudioActive = false;
                button.textContent = 'üé§ START MICROPHONE ENGINE';
                button.classList.remove('active');
                indicator.classList.remove('active');
                document.getElementById('tokenIndicator').classList.remove('active');
                // Stop replay if active
                if (determinism.mode === 'replay') {
                    stopReplayProcessing();
                }
                updateStatus('Audio engine stopped');
            }
        }

        // Token generation function - called every 100ms from processAudio()
        function generateTokens(frequencyData, rmsEnergy, spectralCentroid) {
            if (!frequencyData || frequencyData.length === 0) return;

            const fundamental = frequencyData[0].frequency;
            const harmonics = generatePhiHarmonics(fundamental, 8);
            const harmonicsCountEl = document.getElementById('harmonics-count');
            if (harmonicsCountEl) harmonicsCountEl.textContent = harmonics.length;

            // Record audio frame if recording
            if (determinism.isRecording) {
                recordAudioFrame({
                    rmsEnergy: rmsEnergy,
                    frequencyData: frequencyData,
                    spectralCentroid: spectralCentroid,
                    harmonics: harmonics
                });
            }

            // Generate Audio Frame Token
            generateAudioFrameToken(
                frequencyData,
                rmsEnergy,
                spectralCentroid,
                harmonics
            );

            // Map each frequency to visual particles continuously
            frequencyData.forEach((freqData, idx) => {
                // Sound-to-color mapping
                const colorHue = (freqData.frequency / 20000) * 360;
                const color = new THREE.Color(`hsl(${colorHue}, ${freqData.magnitude * 100}%, 50%)`);
                
                // Create or update particle for this frequency
                if (particles.length < 20) {
                    createParticleFromFrequency(freqData.frequency, freqData.magnitude, color.getHex());
                } else {
                    // Update existing particles with frequency assignment
                    const targetParticle = particles[idx % particles.length];
                    if (targetParticle) {
                        updateParticleFromAudio(targetParticle, freqData.frequency, freqData.magnitude, color.getHex());
                    }
                }
            });

            // Generate œÜ-Harmonic Tokens for each harmonic
            harmonics.forEach((harmonic, idx) => {
                if (idx < frequencyData.length) {
                    generateHarmonicToken(harmonic, frequencyData[idx].magnitude, idx);
                }
            });
        }

        function processAudio() {
            if (!isAudioActive || !analyser) return;

            // Show token generation indicator
            document.getElementById('tokenIndicator').classList.add('active');

            analyser.getByteFrequencyData(dataArray);
            analyser.getByteTimeDomainData(dataArray);

            // Calculate RMS energy
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                const normalized = (dataArray[i] - 128) / 128;
                sum += normalized * normalized;
            }
            audioEnergy = Math.sqrt(sum / dataArray.length);

            // Get frequency data
            analyser.getByteFrequencyData(dataArray);
            
            // CONSTANT TOKEN GENERATION: Extract ALL significant frequencies
            frequencyData = [];
            const tempData = Array.from(dataArray);
            
            // Get top 10 frequencies for token generation
            const indices = tempData.map((val, idx) => ({ val, idx }))
                .sort((a, b) => b.val - a.val)
                .slice(0, 10);
            
            indices.forEach(item => {
                const freq = (item.idx * audioContext.sampleRate) / (2 * bufferLength);
                const magnitude = item.val / 255;
                if (magnitude > 0.05) { // Lower threshold for constant generation
                    frequencyData.push({ frequency: freq, magnitude });
                }
            });

            // Calculate spectral centroid
            let weightedSum = 0;
            let magnitudeSum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                const freq = (i * audioContext.sampleRate) / (2 * bufferLength);
                weightedSum += freq * dataArray[i];
                magnitudeSum += dataArray[i];
            }
            spectralCentroid = magnitudeSum > 0 ? weightedSum / magnitudeSum : 0;

            // Update displays
            document.getElementById('rms-energy').textContent = audioEnergy.toFixed(3);
            document.getElementById('audio-gain').textContent = (1 + audioEnergy * audioSensitivity).toFixed(2);
            
            if (frequencyData.length > 0) {
                document.getElementById('dominant-freq').textContent = frequencyData[0].frequency.toFixed(1);
            }
            document.getElementById('spectral-centroid').textContent = spectralCentroid.toFixed(1);

            // Generate tokens from current audio data
            generateTokens(frequencyData, audioEnergy, spectralCentroid);

            // Update chaos measure
            const chaos = calculateAudioChaos();
            const chaosEl = document.getElementById('audio-chaos');
            if (chaosEl) chaosEl.textContent = chaos.toFixed(3);

            // Frequency visualization is now handled in the animation loop
            // No need to call drawFrequencySpectrum here

            if (isAudioActive) {
                setTimeout(processAudio, 100); // Process every 100ms for constant token generation
            }
        }

        function generatePhiHarmonics(fundamental, count) {
            const harmonics = [];
            for (let i = 0; i < count; i++) {
                let freq = fundamental * Math.pow(phi, i / 2);
                
                // Octave folding
                while (freq > fundamental * 4) {
                    freq /= 2;
                }
                while (freq < fundamental / 2) {
                    freq *= 2;
                }
                
                harmonics.push(freq);
            }
            return harmonics.sort((a, b) => a - b);
        }

        function generateParticleToken(particle, eventType = 'creation') {
            // Token structure from 12D CST specification (extended with new fields)
            const token = {
                id: generateUUID(),
                particleId: particle.id,
                frequency: parseFloat(particle.frequency.toFixed(2)),
                energy: parseFloat(particle.energy.toFixed(6)), // Legacy
                position: [
                    parseFloat(particle.x.toFixed(4)),
                    parseFloat(particle.y.toFixed(4)),
                    parseFloat(particle.z.toFixed(4))
                ],
                velocity: [
                    parseFloat(particle.velocity.x.toFixed(4)),
                    parseFloat(particle.velocity.y.toFixed(4)),
                    parseFloat(particle.velocity.z.toFixed(4))
                ],
                mass: parseFloat(particle.mass.toFixed(3)),
                entropy: parseFloat(particle.entropy.toFixed(3)), // Legacy
                timestamp: Date.now() / 1000, // Unix timestamp
                parent: particle.parent || null,
                eventType: eventType, // 'creation', 'replication', 'frequency_assignment'
                color: '#' + particle.color.toString(16).padStart(6, '0'),
                // 12D CST new fields
                x12: parseFloat(particle.x12.toFixed(4)),
                m12: parseFloat(particle.m12.toFixed(4)),
                Ec: parseFloat(particle.Ec.toFixed(6)),
                Ugrav: parseFloat(particle.Ugrav.toFixed(6)),
                Udm: parseFloat(particle.Udm.toFixed(6)),
                vi: parseFloat(particle.vi.toFixed(2)),
                theta: parseFloat(particle.theta.toFixed(4)),
                omega: parseFloat(particle.omega.toFixed(6)),
                entropyS: parseFloat(particle.entropyS.toFixed(6)),
                neighborCount: particle.neighbors ? particle.neighbors.length : 0
            };
            
            // Add to global tokens array
            tokens.push(token);
            tokenCount++;
            
            // Add to particle's token list
            particle.tokens.push(token);
            
            // Use addToken to handle UI updates, scrolling, and indicators
            addToken(token);
            
            return token;
        }

        function generateAudioFrameToken(frequencyData, rmsEnergy, spectralCentroid, harmonics) {
            // CONTINUOUS audio frame token - captures entire audio state
            const token = {
                id: generateUUID(),
                type: 'audio_frame',
                timestamp: Date.now() / 1000,
                rmsEnergy: parseFloat(rmsEnergy.toFixed(4)),
                spectralCentroid: parseFloat(spectralCentroid.toFixed(2)),
                frequencyCount: frequencyData.length,
                topFrequencies: frequencyData.slice(0, 5).map(f => ({
                    freq: parseFloat(f.frequency.toFixed(2)),
                    magnitude: parseFloat(f.magnitude.toFixed(3))
                })),
                phiHarmonics: harmonics.slice(0, 5).map(h => parseFloat(h.toFixed(2))),
                seed: generateAudioSeed(frequencyData, rmsEnergy), // Deterministic seed
                psi: calculatePsiFromAudio(frequencyData, rmsEnergy, spectralCentroid)
            };
            
            tokens.push(token);
            tokenCount++;
            
            // Use addToken to handle UI updates, scrolling, and indicators
            addToken(token);
            
            return token;
        }

        function flashTokenIndicator() {
            const indicator = document.getElementById('tokenIndicator');
            indicator.classList.add('active');
            setTimeout(() => {
                // Keep it active while audio is processing
                if (!isAudioActive) {
                    indicator.classList.remove('active');
                }
            }, 100);
        }

        function generateHarmonicToken(harmonic, magnitude, index) {
            // Token for each phi-harmonic generated
            const token = {
                id: generateUUID(),
                type: 'phi_harmonic',
                timestamp: Date.now() / 1000,
                harmonic: parseFloat(harmonic.toFixed(2)),
                magnitude: parseFloat(magnitude.toFixed(3)),
                harmonicIndex: index,
                phiRatio: Math.pow(phi, index / 2),
                colorMapping: frequencyToColor(harmonic),
                seed: hashFrequency(harmonic)
            };
            
            tokens.push(token);
            tokenCount++;
            
            // Use addToken to handle UI updates, scrolling, and indicators
            addToken(token);
            
            return token;
        }

        function generateAudioSeed(frequencyData, rmsEnergy) {
            // Generate deterministic seed from audio data
            let seedValue = 0;
            frequencyData.forEach((f, i) => {
                seedValue += f.frequency * f.magnitude * (i + 1);
            });
            seedValue += rmsEnergy * 10000;
            return Math.floor(seedValue) % 1000000;
        }

        function hashFrequency(frequency) {
            // Simple hash for frequency-based seed
            return Math.floor((frequency * phi) % 100000);
        }

        function frequencyToColor(frequency) {
            // Sound-to-color mapping
            const hue = (frequency / 20000) * 360;
            const saturation = 100;
            const lightness = 50;
            return `hsl(${hue.toFixed(0)}, ${saturation}%, ${lightness}%)`;
        }

        function calculatePsiFromAudio(frequencyData, rmsEnergy, spectralCentroid) {
            // Calculate œà directly from audio using the 12D formula
            const mass = 1;
            const energyComponent = (phi * mass * c * c * rmsEnergy) / (c * c);
            const lambdaComponent = Math.log(spectralCentroid + 1) / 100;
            const frequencyIntegral = frequencyData.reduce((sum, f) => sum + f.frequency * f.magnitude, 0) / 1000;
            const omegaComponent = frequencyData.length * rmsEnergy * phi;
            
            return energyComponent + phi + lambdaComponent + frequencyIntegral + omegaComponent;
        }

        function createParticleFromFrequency(frequency, magnitude, color) {
            // Create new particle from frequency data
            const offset = particles.length * 0.1;
            const particle = new LorenzParticle(
                Math.random() * 10 - 5,
                Math.random() * 10 - 5,
                Math.random() * 10 - 5,
                color,
                frequency,
                null
            );
            
            particle.mass = 1 + magnitude * 5;
            particle.energy = magnitude * 50;
            particles.push(particle);

            // Generate creation token
            generateParticleToken(particle, 'audio_creation');
        }

        function updateParticleFromAudio(particle, frequency, magnitude, color) {
            // Update existing particle with new audio data
            particle.frequency = frequency;
            particle.color = color;
            particle.line.material.color.setHex(color);
            particle.sphere.material.color.setHex(color);
            particle.mass = Math.max(1, particle.mass * (0.95 + magnitude * 0.1));
            
            // Generate frequency update token
            const token = {
                id: generateUUID(),
                type: 'frequency_update',
                particleId: particle.id,
                frequency: parseFloat(frequency.toFixed(2)),
                magnitude: parseFloat(magnitude.toFixed(3)),
                color: '#' + color.toString(16).padStart(6, '0'),
                timestamp: Date.now() / 1000
            };
            
            tokens.push(token);
            tokenCount++;
            particle.tokens.push(token);
            
            // Use addToken to handle UI updates, scrolling, and indicators
            addToken(token);
        }

        function calculateAudioChaos() {
            if (frequencyData.length < 2) return 0;
            
            let variance = 0;
            const mean = frequencyData.reduce((sum, d) => sum + d.magnitude, 0) / frequencyData.length;
            frequencyData.forEach(d => {
                variance += Math.pow(d.magnitude - mean, 2);
            });
            return Math.sqrt(variance / frequencyData.length);
        }

        function addParticleFromAudio(frequency, energy) {
            const offset = particles.length * 0.1;
            const hue = (frequency / 20000) * 360;
            const color = new THREE.Color(`hsl(${hue}, 100%, 50%)`);
            
            const particle = new LorenzParticle(
                0.1 + offset + energy * 5,
                offset,
                offset,
                color.getHex(),
                frequency,
                null // No parent for audio-generated particles
            );
            
            particle.mass = 1 + energy * 10;
            particles.push(particle);

            // Generate creation token
            generateParticleToken(particle, 'creation');
            
            updateStatus(`Audio particle created: ${frequency.toFixed(1)}Hz, E=${energy.toFixed(3)}`);
        }

        function updateTokenDisplay() {
            const display = document.getElementById('tokenDisplay');
            if (tokens.length === 0) {
                display.innerHTML = '<div class="token-item">Waiting for audio input...</div>';
                document.getElementById('token-count').textContent = '0';
                return;
            }
            
            // Show last 8 tokens in reverse chronological order
            const recentTokens = tokens.slice(-8).reverse();
            display.innerHTML = recentTokens.map(t => {
                // Different display formats based on token type
                if (t.type === 'audio_frame') {
                    return `<div class="token-item">
                        <strong>üéµ AUDIO FRAME</strong> ${t.id.substr(0, 13)}...<br>
                        <strong>RMS:</strong> ${t.rmsEnergy} | <strong>Centroid:</strong> ${t.spectralCentroid}Hz<br>
                        <strong>Top Freq:</strong> ${t.topFrequencies[0]?.freq || 0}Hz<br>
                        <strong>Seed:</strong> ${t.seed} | <strong>œà:</strong> ${t.psi?.toFixed(2)}
                    </div>`;
                } else if (t.type === 'phi_harmonic') {
                    return `<div class="token-item">
                        <strong>üåÄ œÜ-HARMONIC #${t.harmonicIndex}</strong><br>
                        <strong>Freq:</strong> ${t.harmonic}Hz | <strong>Mag:</strong> ${t.magnitude}<br>
                        <strong>œÜ^${(t.harmonicIndex / 2).toFixed(1)}:</strong> ${t.phiRatio?.toFixed(3)}<br>
                        <strong>Color:</strong> <span style="color: ${t.colorMapping}">${t.colorMapping}</span> | <strong>Seed:</strong> ${t.seed}
                    </div>`;
                } else if (t.type === 'frequency_update') {
                    return `<div class="token-item">
                        <strong>üîÑ FREQ UPDATE</strong> Particle: ${t.particleId.substr(0, 8)}...<br>
                        <strong>Freq:</strong> ${t.frequency}Hz | <strong>Mag:</strong> ${t.magnitude}<br>
                        <strong>Color:</strong> <span style="color: ${t.color}">${t.color}</span>
                    </div>`;
                } else {
                    // Standard particle token
                    const parentInfo = t.parent ? `Parent: ${t.parent.substr(0, 8)}...` : 'No parent';
                    const posStr = `[${t.position[0].toFixed(1)}, ${t.position[1].toFixed(1)}, ${t.position[2].toFixed(1)}]`;
                    return `<div class="token-item">
                        <strong>‚öõÔ∏è ${t.eventType?.toUpperCase()}</strong> ${t.id.substr(0, 13)}...<br>
                        <strong>Freq:</strong> ${t.frequency}Hz | <strong>E:</strong> ${t.energy?.toFixed(3)}<br>
                        <strong>Pos:</strong> ${posStr}<br>
                        <strong>${parentInfo}</strong>
                    </div>`;
                }
            }).join('');
            
            document.getElementById('token-count').textContent = tokens.length;
        }

        // ============================================================================
        // ANIMATION MODULES - Real-time updates and smooth transitions
        // ============================================================================
        
        // State buffers for frequency spectrum smoothing
        let lastFreqBars = null;
        let freqLerp = 0.25; // smoothing factor
        
        // 1) Frequency spectrum animation
        function updateFrequencyViz(freqs, mags) {
            if (!freqCtx || !freqCanvas) return;
            
            // Use provided parameters or read from analyser
            let bars = null;
            let binCount = 0;
            let currentRMS = audioEnergy || 0;
            let currentDominantFreq = 0;
            let currentSpectralCentroid = 0;
            
            if (freqs && mags && freqs.length > 0) {
                // Use provided frequency data
                binCount = Math.max(freqs.length, 100); // Default to 100 bins if not specified
                bars = new Array(binCount).fill(0);
                freqs.forEach((f, i) => {
                    const bin = Math.min(binCount - 1, Math.floor((f / 20000) * binCount));
                    if (mags[i] !== undefined) {
                        bars[bin] = Math.max(bars[bin], mags[i]);
                    }
                });
                
                // Calculate RMS, dominant frequency, and spectral centroid from provided data
                if (mags.length > 0) {
                    const sumSq = mags.reduce((sum, m) => sum + m * m, 0);
                    currentRMS = Math.sqrt(sumSq / mags.length);
                    currentDominantFreq = freqs[0] || 0;
                    
                    // Calculate spectral centroid
                    let weightedSum = 0;
                    let magnitudeSum = 0;
                    freqs.forEach((f, i) => {
                        weightedSum += f * (mags[i] || 0);
                        magnitudeSum += (mags[i] || 0);
                    });
                    currentSpectralCentroid = magnitudeSum > 0 ? weightedSum / magnitudeSum : 0;
                }
            } else if (analyser && dataArray && bufferLength > 0) {
                // Read from analyser (live audio)
                analyser.getByteFrequencyData(dataArray);
                binCount = bufferLength;
                bars = Array.from(dataArray, v => v / 255);
                
                // Calculate RMS from time domain data
                analyser.getByteTimeDomainData(dataArray);
                let sum = 0;
                for (let i = 0; i < dataArray.length; i++) {
                    const normalized = (dataArray[i] - 128) / 128;
                    sum += normalized * normalized;
                }
                currentRMS = Math.sqrt(sum / dataArray.length);
                
                // Get dominant frequency and spectral centroid from frequency data
                analyser.getByteFrequencyData(dataArray);
                let maxMag = 0;
                let maxIdx = 0;
                let weightedSum = 0;
                let magnitudeSum = 0;
                if (audioContext && audioContext.sampleRate) {
                    for (let i = 0; i < dataArray.length; i++) {
                        const mag = dataArray[i] / 255;
                        if (mag > maxMag) {
                            maxMag = mag;
                            maxIdx = i;
                        }
                        const freq = (i * audioContext.sampleRate) / (2 * bufferLength);
                        weightedSum += freq * dataArray[i];
                        magnitudeSum += dataArray[i];
                    }
                    currentDominantFreq = (maxIdx * audioContext.sampleRate) / (2 * bufferLength);
                    currentSpectralCentroid = magnitudeSum > 0 ? weightedSum / magnitudeSum : 0;
                }
            } else if (determinism.mode === 'replay' && frequencyData && frequencyData.length > 0) {
                // Use global frequencyData from replay mode
                binCount = 100; // Default bin count
                bars = new Array(binCount).fill(0);
                const freqs = frequencyData.map(f => f.frequency);
                const mags = frequencyData.map(f => f.magnitude);
                
                freqs.forEach((f, i) => {
                    const bin = Math.min(binCount - 1, Math.floor((f / 20000) * binCount));
                    if (mags[i] !== undefined) {
                        bars[bin] = Math.max(bars[bin], mags[i]);
                    }
                });
                
                currentRMS = audioEnergy || 0;
                currentDominantFreq = freqs.length > 0 ? freqs[0] : 0;
                
                // Calculate spectral centroid
                let weightedSum = 0;
                let magnitudeSum = 0;
                freqs.forEach((f, i) => {
                    weightedSum += f * (mags[i] || 0);
                    magnitudeSum += (mags[i] || 0);
                });
                currentSpectralCentroid = magnitudeSum > 0 ? weightedSum / magnitudeSum : spectralCentroid || 0;
            } else {
                // No data available
                return;
            }

            // Update RMS energy, dominant frequency, and spectral centroid displays
            const rmsEl = document.getElementById('rms-energy');
            const dominantEl = document.getElementById('dominant-freq');
            const centroidEl = document.getElementById('spectral-centroid');
            if (rmsEl) rmsEl.textContent = currentRMS.toFixed(3);
            if (dominantEl) dominantEl.textContent = currentDominantFreq.toFixed(1);
            if (centroidEl) centroidEl.textContent = currentSpectralCentroid.toFixed(1);
            
            const width = freqCanvas.width;
            const height = freqCanvas.height;
            const barW = (width / binCount) * 2.0;

            // Prepare smoothed bars
            if (!lastFreqBars || lastFreqBars.length !== bars.length) {
                lastFreqBars = bars.slice();
            } else {
                for (let i = 0; i < bars.length; i++) {
                    lastFreqBars[i] = lastFreqBars[i] + freqLerp * (bars[i] - lastFreqBars[i]);
                }
            }
            
            // Clear canvas
            freqCtx.clearRect(0, 0, width, height);
            freqCtx.fillStyle = 'rgba(10, 10, 26, 0.25)';
            freqCtx.fillRect(0, 0, width, height);
            
            // Draw bars with hue mapping (0‚Äì360)
            let x = 0;
            for (let i = 0; i < binCount; i++) {
                const hue = (i / binCount) * 360;
                const barH = lastFreqBars[i] * height;
                freqCtx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                freqCtx.fillRect(x, height - barH, barW, barH);
                x += barW + 1;
            }
        }
        
        // Legacy function for compatibility (calls new function)
        function drawFrequencySpectrum() {
            updateFrequencyViz();
        }
        
        // 2) Lorenz attractor particle animation update
        function updateLorenzParticles() {
            if (particles.length === 0 || isPaused) return;

            // Adaptive dt is updated in animate() before this call
            const spatialIndex = buildSpatialIndex(particles, physics.rCutoff);
            const gravAccelerations = computeGravitationalAccelerations(particles, spatialIndex, physics);
            computeGravitationalEnergy(particles, spatialIndex, physics);
            computeDarkMatterPotential(particles, dmParams);
                computeSynapticStrength(particles, spatialIndex, physics, adapt);
            updateAdaptiveStates(particles, adapt, timestep.dt);
            updatePhases(particles, sync, spatialIndex, timestep.dt);

            // Audio modulation
                const audioMod = isAudioActive ? audioEnergy * audioSensitivity : 0;

            // Update particle trajectories and visuals
                let chaosSum = 0;
            particles.forEach((p, i) => {
                const accel = gravAccelerations[i];
                const d = p.update(audioMod, accel);
                chaosSum += Math.abs(d.dx) + Math.abs(d.dy) + Math.abs(d.dz);
                });

            // Recompute energies and vi
            particles.forEach(p => {
                const v2 = p.velocity.x*p.velocity.x + p.velocity.y*p.velocity.y + p.velocity.z*p.velocity.z;
                const K = 0.5 * p.mass * v2;
                p.Ec = K + p.Ugrav + p.Udm;
                p.vi = p.Ec / h;
            });
            
            // Entropy every N frames (performance)
                if (frameCount % 10 === 0) {
                    computeEntropy(particles, kB, 32);
                }

            // œà normalized breakdown
            const psiResult = updatePsiNormalized(particles, physics, psiAccumulators);
            updatePsi(chaosSum, psiResult);
            
            // Camera slow orbit
            const t = Date.now() * 0.0001;
            camera.position.x = Math.cos(t) * 60;
            camera.position.z = Math.sin(t) * 60;
            camera.lookAt(0, 20, 0);
            
            // Conservation and virial (batched updates)
                const consStats = computeConservationStats(particles);
                if (conservationStats.E0 === 0) {
                    conservationStats.E0 = consStats.Etotal;
                conservationStats.P0 = { ...consStats.P };
                conservationStats.L0 = { ...consStats.L };
                }
            const virial = checkVirial(particles);
            const syncMetric = computeSynchronizationMetric(particles);

            // UI updates throttled
            if (frameCount % Math.floor(60 / Math.max(timestep.dt, 0.01)) === 0) {
                updateAdvancedUI(consStats, virial, psiResult, syncMetric);
            }
        }
        
        // 3) Token stream animation and indicators
        // Add token to display and update UI
        function addToken(tokenObj) {
            if (!tokenObj) return;
            
            // Token is already in tokens array (added by generateParticleToken or generateAudioFrameToken)
            // Update the display
            updateTokenDisplay();
            
            // Smooth scroll to bottom
            const display = document.getElementById('tokenDisplay');
            if (display) {
                // Use requestAnimationFrame for smooth scrolling
                requestAnimationFrame(() => {
                    const isNearBottom = display.scrollHeight - display.scrollTop - display.clientHeight < 50;
                    if (isNearBottom) {
                        display.scrollTop = display.scrollHeight;
                    }
                });
            }
            
            // Flash indicator briefly
            const indicator = document.getElementById('tokenIndicator');
            if (indicator) {
                indicator.classList.add('active');
                // Remove active class after 300ms for flash effect
                setTimeout(() => {
                    indicator.classList.remove('active');
                }, 300);
            }
            
            // Increment counters immediately
            const countEl = document.getElementById('token-count');
            const countStatusEl = document.getElementById('token-count-status');
            if (countEl) countEl.textContent = tokens.length;
            if (countStatusEl) countStatusEl.textContent = tokens.length;
        }
        
        function updateTokenStream() {
            // Skip token generation in replay mode (handled by processReplayAudio)
            if (determinism.mode === 'replay') {
                return;
            }
            
            // Called each frame, but actual generation every 100ms
            const now = Date.now();
            if (now - lastTokenTime >= 100) {
                // Generate tokens if audio is active or if we have frequency data
                if (isAudioActive && frequencyData && frequencyData.length > 0) {
                    // Use the full generateTokens function with audio data
                    generateTokens(frequencyData, audioEnergy, spectralCentroid || 0);
                } else if (isAudioActive) {
                    // Simple token generation when audio is active but no frequency data yet
                    const simpleToken = `Token_${Date.now()}`;
                    tokens.push(simpleToken);
                    tokenCount++;
                    replicationCount++;
                    
                    const display = document.getElementById('tokenDisplay');
                    if (display) {
                        const item = document.createElement('div');
                        item.className = 'token-item';
                        item.textContent = simpleToken;
                        display.appendChild(item);
                        display.scrollTop = display.scrollHeight;
                    }
                    
                    const countEl = document.getElementById('token-count');
                    const countStatusEl = document.getElementById('token-count-status');
                    if (countEl) countEl.textContent = tokenCount;
                    if (countStatusEl) countStatusEl.textContent = tokenCount;
                    
                    const indicator = document.getElementById('tokenIndicator');
                    if (indicator) {
                        indicator.classList.add('active');
                        setTimeout(() => indicator.classList.remove('active'), 500);
                    }
                }
                lastTokenTime = now;
            }
            
            // Smooth scroll to bottom
            const display = document.getElementById('tokenDisplay');
            if (!display) return;
            
            // Only scroll if near bottom (within 50px) to avoid interrupting user scrolling
            const isNearBottom = display.scrollHeight - display.scrollTop - display.clientHeight < 50;
            if (isNearBottom) {
                display.scrollTop = display.scrollHeight;
            }
            
            // Flash indicator briefly if new tokens detected
            const indicator = document.getElementById('tokenIndicator');
            if (indicator && tokens.length !== lastTokenCount) {
                indicator.classList.add('active');
                // Remove active class after 300ms for flash effect
                setTimeout(() => {
                    indicator.classList.remove('active');
                }, 300);
            }
        }
        
        // Update token rate once per second
        function updateTokenRate() {
            const now = Date.now();
            const timeDiff = (now - lastTokenRateTime) / 1000;
            if (timeDiff >= 1) {
                tokenGenerationRate = tokenCount - lastTokenCount;
                lastTokenCount = tokenCount;
                lastTokenRateTime = now;
                
                const rateEl = document.getElementById('token-rate');
                if (rateEl) rateEl.textContent = tokenGenerationRate.toFixed(1);
            }
        }
        
        // Alias for compatibility
        function updateTokenCountersOncePerSecond() {
            updateTokenRate();
        }
        
        // 4) Chaos, Lyapunov, and synchronization displays
        function updateChaosMetrics() {
            const chaos = calculateAudioChaos();
            let lyapunov = 0;
            
            if (particles.length > 0) {
                // Calculate chaos sum from particle derivatives
                let chaosSum = 0;
                particles.forEach(p => {
                    const v = Math.sqrt(p.velocity.x*p.velocity.x + p.velocity.y*p.velocity.y + p.velocity.z*p.velocity.z);
                    chaosSum += Math.abs(v);
                });
                lyapunov = Math.abs(Math.log(Math.abs(chaosSum) + 1) / 10) + (isAudioActive ? chaos : 0);
            }
            
            const lyEl = document.getElementById('lyapunov-value');
            const chaosEl = document.getElementById('audio-chaos');
            if (lyEl) lyEl.textContent = lyapunov.toFixed(3);
            if (chaosEl) chaosEl.textContent = chaos.toFixed(3);
        }
        
        // 5) Conservation diagnostics animation
        function updateConservationDiagnostics() {
            if (particles.length === 0) return;
            
            const consStats = computeConservationStats(particles);
            const virial = checkVirial(particles);
            
            const eTotalEl = document.getElementById('conservation-etotal');
            const eDriftEl = document.getElementById('conservation-edrift');
            const pMagEl = document.getElementById('conservation-pmag');
            const lMagEl = document.getElementById('conservation-lmag');
            const virialEl = document.getElementById('conservation-virial');
            
            if (eTotalEl) eTotalEl.textContent = consStats.Etotal.toExponential(2);
            if (eDriftEl) eDriftEl.textContent = (consStats.drift.E * 100).toFixed(2) + '%';
            if (pMagEl) pMagEl.textContent = Math.sqrt(consStats.P.x**2 + consStats.P.y**2 + consStats.P.z**2).toExponential(2);
            if (lMagEl) lMagEl.textContent = Math.sqrt(consStats.L.x**2 + consStats.L.y**2 + consStats.L.z**2).toExponential(2);
            if (virialEl) virialEl.textContent = virial.ratio.toFixed(3) + (virial.ok ? ' ‚úì' : ' ‚úó');
        }
        
        // 6) Replay and determinism feedback
        function reflectDeterminismUI() {
            const status = document.getElementById('recording-status');
            const replayBtn = document.getElementById('replay-btn');
            if (!status || !replayBtn) return;
            
            if (determinism.isRecording) {
                status.textContent = `Recording audio frames... (${determinism.recordedAudioFrames.length} frames)`;
            } else {
                status.textContent = `Recording stopped. ${determinism.recordedAudioFrames.length} frames recorded.`;
            }
            replayBtn.textContent = determinism.mode === 'replay' ? '‚èπÔ∏è Stop Replay' : '‚ñ∂Ô∏è Replay';
        }
        
        // Standalone synchronization metrics update function
        function updateSynchronizationMetrics() {
            if (particles.length === 0) return;
            
            const syncMetric = computeSynchronizationMetric(particles);
            const syncREl = document.getElementById('sync-r');
            const syncMeanEl = document.getElementById('sync-mean');
            
            if (syncREl) syncREl.textContent = syncMetric.r.toFixed(3);
            if (syncMeanEl) syncMeanEl.textContent = (syncMetric.meanTheta * 180 / Math.PI).toFixed(1) + '¬∞';
        }
        
        // Standalone œà breakdown update function
        function updatePsiBreakdown() {
            if (particles.length === 0) return;
            
            const psiResult = updatePsiNormalized(particles, physics, psiAccumulators);
            
            const psiEnergyEl = document.getElementById('psi-energy-term');
            const psiLambdaEl = document.getElementById('psi-lambda-term');
            const psiVelIntEl = document.getElementById('psi-velint-term');
            const psiX12IntEl = document.getElementById('psi-x12int-term');
            const psiOmegaEl = document.getElementById('psi-omega-term');
            const psiPotentialEl = document.getElementById('psi-potential-term');
            const psiTotalEl = document.getElementById('psi-total-normalized');
            
            if (psiEnergyEl) psiEnergyEl.textContent = psiResult.terms.energyTerm.toFixed(3);
            if (psiLambdaEl) psiLambdaEl.textContent = psiResult.terms.lambdaTerm.toFixed(3);
            if (psiVelIntEl) psiVelIntEl.textContent = psiResult.terms.velocityIntegralTerm.toFixed(3);
            if (psiX12IntEl) psiX12IntEl.textContent = psiResult.terms.x12IntegralTerm.toFixed(3);
            if (psiOmegaEl) psiOmegaEl.textContent = psiResult.terms.omegaTerm.toFixed(3);
            if (psiPotentialEl) psiPotentialEl.textContent = psiResult.terms.potentialTerm.toFixed(3);
            if (psiTotalEl) psiTotalEl.textContent = psiResult.psiTotal.toFixed(3);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (!isPaused) {
                // Adaptive timestep
                const adaptiveDtCheckbox = document.getElementById('adaptive-dt');
                if (adaptiveDtCheckbox && adaptiveDtCheckbox.checked && particles.length > 0) {
                    timestep.dt = computeAdaptiveDt(particles, physics, timestep);
                }

                // Update Lorenz particles with full physics
                if (particles.length > 0) {
                    updateLorenzParticles();
                }
                
                // Draw frequency spectrum
                drawFrequencySpectrum();
                
                // Update metrics
                updateChaosMetrics();
                updateSynchronizationMetrics();
                updateConservationDiagnostics();
                updatePsiBreakdown();
                
                // Update token stream
                updateTokenStream();
                updateTokenRate();
            }

            // Render Three.js scene
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }

            // FPS counter
            frameCount++;
            const now = performance.now();
            if (now >= lastTime + 1000) {
                const fpsEl = document.getElementById('fps');
                if (fpsEl) fpsEl.textContent = frameCount;
                const particleEl = document.getElementById('particle-count');
                const tokenEl = document.getElementById('token-count-status');
                const replEl = document.getElementById('replication-count');
                if (particleEl) particleEl.textContent = particles.length;
                if (tokenEl) tokenEl.textContent = tokens.length;
                if (replEl) replEl.textContent = replicationCount;
                frameCount = 0;
                lastTime = now;
            }
        }
        
        // Update advanced UI displays
        function updateAdvancedUI(consStats, virial, psiResult, syncMetric) {
            // Update conservation displays if elements exist
            const eTotalEl = document.getElementById('conservation-etotal');
            const eDriftEl = document.getElementById('conservation-edrift');
            const pMagEl = document.getElementById('conservation-pmag');
            const lMagEl = document.getElementById('conservation-lmag');
            const virialEl = document.getElementById('conservation-virial');
            
            if (eTotalEl) eTotalEl.textContent = consStats.Etotal.toExponential(2);
            if (eDriftEl) eDriftEl.textContent = (consStats.drift.E * 100).toFixed(2) + '%';
            if (pMagEl) pMagEl.textContent = Math.sqrt(consStats.P.x**2 + consStats.P.y**2 + consStats.P.z**2).toExponential(2);
            if (lMagEl) lMagEl.textContent = Math.sqrt(consStats.L.x**2 + consStats.L.y**2 + consStats.L.z**2).toExponential(2);
            if (virialEl) virialEl.textContent = virial.ratio.toFixed(3) + (virial.ok ? ' ‚úì' : ' ‚úó');
            
            // Update synchronization displays
            const syncREl = document.getElementById('sync-r');
            const syncMeanEl = document.getElementById('sync-mean');
            if (syncREl) syncREl.textContent = syncMetric.r.toFixed(3);
            if (syncMeanEl) syncMeanEl.textContent = (syncMetric.meanTheta * 180 / Math.PI).toFixed(1) + '¬∞';
            
            // Update psi breakdown displays
            const psiEnergyEl = document.getElementById('psi-energy-term');
            const psiLambdaEl = document.getElementById('psi-lambda-term');
            const psiVelIntEl = document.getElementById('psi-velint-term');
            const psiX12IntEl = document.getElementById('psi-x12int-term');
            const psiOmegaEl = document.getElementById('psi-omega-term');
            const psiPotentialEl = document.getElementById('psi-potential-term');
            const psiTotalEl = document.getElementById('psi-total-normalized');
            
            if (psiEnergyEl) psiEnergyEl.textContent = psiResult.terms.energyTerm.toFixed(3);
            if (psiLambdaEl) psiLambdaEl.textContent = psiResult.terms.lambdaTerm.toFixed(3);
            if (psiVelIntEl) psiVelIntEl.textContent = psiResult.terms.velocityIntegralTerm.toFixed(3);
            if (psiX12IntEl) psiX12IntEl.textContent = psiResult.terms.x12IntegralTerm.toFixed(3);
            if (psiOmegaEl) psiOmegaEl.textContent = psiResult.terms.omegaTerm.toFixed(3);
            if (psiPotentialEl) psiPotentialEl.textContent = psiResult.terms.potentialTerm.toFixed(3);
            if (psiTotalEl) psiTotalEl.textContent = psiResult.psiTotal.toFixed(3);
        }

        function addParticle() {
            const offset = particles.length * 0.1;
            const color = new THREE.Color(`hsl(${colorHue + offset * 30}, 100%, 50%)`);
            const particle = new LorenzParticle(0.1 + offset, offset, offset, color.getHex(), 440 + offset * 100);
            particles.push(particle);
            
            // Generate creation token
            generateParticleToken(particle, 'creation');
            
            updateStatus(`Added trajectory ${particles.length}`);
        }

        function resetSystem() {
            particles.forEach(p => p.destroy());
            particles = [];
            tokens = [];
            tokenCount = 0;
            replicationCount = 0;
            // Reset conservation stats
            conservationStats.E0 = 0;
            conservationStats.P0 = { x: 0, y: 0, z: 0 };
            conservationStats.L0 = { x: 0, y: 0, z: 0 };
            // Reset psi accumulators
            psiAccumulators.velocityIntegral.clear();
            psiAccumulators.x12Integral.clear();
            updateTokenDisplay();
            addParticle();
            updateStatus('System reset - New trajectory initialized');
        }

        function togglePause() {
            isPaused = !isPaused;
            updateStatus(isPaused ? 'Simulation paused' : 'Simulation running');
        }

        function changeColor() {
            colorHue = (colorHue + 60) % 360;
            particles.forEach((p, i) => {
                const color = new THREE.Color(`hsl(${colorHue + i * 30}, 100%, 50%)`);
                p.line.material.color.setHex(color.getHex());
                p.sphere.material.color.setHex(color.getHex());
            });
            updateStatus('Color scheme updated');
        }

        function updatePsi(chaosSum, psiResult = null) {
            const mass = 1;
            const energy = mass * c * c;
            const audioGain = 1 + (isAudioActive ? audioEnergy * audioSensitivity : 0);
            const energyComponent = mass * audioGain;
            
            // Calculate Lyapunov approximation
            const audioChaos = isAudioActive ? calculateAudioChaos() : 0;
            const lyapunov = Math.abs(Math.log(Math.abs(chaosSum) + 1) / 10) + audioChaos;
            
            document.getElementById('energy-value').textContent = (energy * audioGain).toExponential(2);
            document.getElementById('lyapunov-value').textContent = lyapunov.toFixed(3);
            
            // Calculate œà components (legacy display)
                const psiEnergy = energyComponent;
                const psiPhi = phi;
                const psiLambda = lyapunov;
                const psiOmega = chaosSum;
            const psiTotal = psiResult ? psiResult.psiTotal : (psiEnergy + psiPhi + psiLambda + psiOmega);
                
                document.getElementById('psi-energy').textContent = psiEnergy.toFixed(3);
                document.getElementById('psi-phi').textContent = psiPhi.toFixed(3);
                document.getElementById('psi-lambda').textContent = psiLambda.toFixed(3);
                document.getElementById('psi-omega').textContent = psiOmega.toFixed(2);
                document.getElementById('psi-total').textContent = psiTotal.toFixed(3);
        }

        function updateStatus(message) {
            document.getElementById('system-status').textContent = message;
        }

        function exportTokens() {
            if (tokens.length === 0) {
                alert('No tokens to export yet! Start the microphone or add particles.');
                return;
            }
            
            // Calculate token type statistics
            const tokenTypes = {
                audio_frame: tokens.filter(t => t.type === 'audio_frame').length,
                phi_harmonic: tokens.filter(t => t.type === 'phi_harmonic').length,
                frequency_update: tokens.filter(t => t.type === 'frequency_update').length,
                particle_creation: tokens.filter(t => t.eventType === 'creation' || t.eventType === 'audio_creation').length,
                particle_replication: tokens.filter(t => t.eventType === 'replication').length
            };
            
            const exportData = {
                metadata: {
                    exportDate: new Date().toISOString(),
                    totalTokens: tokens.length,
                    tokenGenerationRate: tokenGenerationRate.toFixed(2) + ' tokens/sec',
                    engine: '12D Cosmic Synapse Theory',
                    version: '2.0',
                    mode: 'Continuous Audio-Driven Token Generation',
                    formula: 'œà = œÜE/c¬≤ + Œª + ‚à´v¬∑dt + ‚à´Œîx‚ÇÅ‚ÇÇ¬∑dt + Œ©E + U‚ÇÅ‚ÇÅD',
                    particleCount: particles.length,
                    replicationCount: replicationCount,
                    tokenTypes: tokenTypes
                },
                tokens: tokens
            };
            
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `cosmic_tokens_continuous_${Date.now()}.json`;
            link.click();
            
            URL.revokeObjectURL(url);
            updateStatus(`üì¶ Exported ${tokens.length} tokens (${tokenGenerationRate.toFixed(1)} tokens/sec) to JSON file`);
        }

        function clearTokens() {
            if (confirm('Clear all tokens? This cannot be undone.')) {
                tokens = [];
                tokenCount = 0;
                replicationCount = 0;
                particles.forEach(p => p.tokens = []);
                updateTokenDisplay();
                updateStatus('All tokens cleared');
            }
        }

        // Event listeners
        document.getElementById('sigma').addEventListener('input', (e) => {
            sigma = parseFloat(e.target.value);
            document.getElementById('sigma-display').textContent = sigma.toFixed(1);
        });

        document.getElementById('rho').addEventListener('input', (e) => {
            rho = parseFloat(e.target.value);
            document.getElementById('rho-display').textContent = rho.toFixed(1);
        });

        document.getElementById('beta').addEventListener('input', (e) => {
            beta = parseFloat(e.target.value);
            document.getElementById('beta-display').textContent = beta.toFixed(3);
        });

        document.getElementById('sensitivity').addEventListener('input', (e) => {
            audioSensitivity = parseFloat(e.target.value);
            document.getElementById('sensitivity-display').textContent = audioSensitivity.toFixed(1);
        });

        document.getElementById('replication').addEventListener('input', (e) => {
            replicationThreshold = parseFloat(e.target.value);
            document.getElementById('replication-display').textContent = replicationThreshold.toFixed(0);
        });

        // 12D CST Event Listeners
        document.getElementById('blend-lorenz').addEventListener('input', (e) => {
            physics.blendLorenz = parseFloat(e.target.value);
            document.getElementById('blend-lorenz-display').textContent = physics.blendLorenz.toFixed(2);
        });

        document.getElementById('grav-enabled').addEventListener('change', (e) => {
            physics.gravEnabled = e.target.checked;
        });

        document.getElementById('dm-enabled').addEventListener('change', (e) => {
            physics.dmEnabled = e.target.checked;
        });

        document.getElementById('rcutoff').addEventListener('input', (e) => {
            physics.rCutoff = parseFloat(e.target.value);
            document.getElementById('rcutoff-display').textContent = physics.rCutoff.toFixed(1);
        });

        document.getElementById('epsilon').addEventListener('input', (e) => {
            physics.epsilon = parseFloat(e.target.value);
            document.getElementById('epsilon-display').textContent = physics.epsilon.toFixed(2);
        });

        document.getElementById('k').addEventListener('input', (e) => {
            adapt.k = parseFloat(e.target.value);
            document.getElementById('k-display').textContent = adapt.k.toFixed(1);
        });

        document.getElementById('gamma').addEventListener('input', (e) => {
            adapt.gamma = parseFloat(e.target.value);
            document.getElementById('gamma-display').textContent = adapt.gamma.toFixed(2);
        });

        document.getElementById('alpha').addEventListener('input', (e) => {
            adapt.alpha = parseFloat(e.target.value);
            document.getElementById('alpha-display').textContent = adapt.alpha.toFixed(2);
        });

        document.getElementById('sigma-sim').addEventListener('input', (e) => {
            adapt.sigmaSimilarity = parseFloat(e.target.value);
            document.getElementById('sigma-sim-display').textContent = adapt.sigmaSimilarity.toFixed(2);
        });

        document.getElementById('ksync').addEventListener('input', (e) => {
            sync.Ksync = parseFloat(e.target.value);
            document.getElementById('ksync-display').textContent = sync.Ksync.toFixed(2);
        });

        document.getElementById('dtmax').addEventListener('input', (e) => {
            timestep.dtMax = parseFloat(e.target.value);
            document.getElementById('dtmax-display').textContent = timestep.dtMax.toFixed(3);
        });

        document.getElementById('adaptive-dt').addEventListener('change', (e) => {
            timestep.adaptive = e.target.checked;
        });

        document.getElementById('dm-rho0').addEventListener('input', (e) => {
            dmParams.rho0 = parseFloat(e.target.value);
            document.getElementById('dm-rho0-display').textContent = dmParams.rho0.toFixed(1);
        });

        document.getElementById('dm-rs').addEventListener('input', (e) => {
            dmParams.rs = parseFloat(e.target.value);
            document.getElementById('dm-rs-display').textContent = dmParams.rs.toFixed(1);
        });

        // Recording and replay functions
        function toggleRecording() {
            determinism.isRecording = !determinism.isRecording;
            const btn = document.getElementById('record-btn');
            if (determinism.isRecording) {
                btn.textContent = '‚èπÔ∏è Stop Recording';
                determinism.recordedAudioFrames = [];
            } else {
                btn.textContent = 'üî¥ Start Recording';
            }
            reflectDeterminismUI();
        }

        function toggleReplay() {
            if (determinism.mode === 'replay') {
                determinism.mode = 'live';
                stopReplayProcessing();
                updateStatus('Replay mode disabled - back to live mode');
            } else {
                if (determinism.recordedAudioFrames.length > 0) {
                    toggleReplayMode({
                        recordedAudioFrames: determinism.recordedAudioFrames,
                        seed: determinism.seed || 12345
                    });
                    updateStatus(`Replay mode enabled - ${determinism.recordedAudioFrames.length} frames`);
                } else {
                    alert('No recorded frames available. Start recording first.');
                }
            }
            reflectDeterminismUI();
        }

        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            initThree();
            initFrequencyCanvas();
            updatePsi(0);
            updateStatus('üé§ System ready - Click START MICROPHONE for continuous audio‚Üítoken generation pipeline');
            animate(); // Start animation loop
        });
    </script>
</body>
</html>