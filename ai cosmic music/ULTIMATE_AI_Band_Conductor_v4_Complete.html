<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ULTIMATE AI Band Conductor - Full Vibrational Intelligence</title>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            --dark-bg: linear-gradient(135deg, #0a0e27, #1a1f3a, #2d1b3d);
            --card-bg: rgba(255,255,255,0.08);
            --border-color: rgba(255,255,255,0.1);
            --success-color: #4ade80;
            --warning-color: #fbbf24;
            --error-color: #f87171;
            --music-color: #a78bfa;
        }
        
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: var(--dark-bg);
            color: white;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1900px;
            margin: 0 auto;
        }
        
        .hero-header {
            text-align: center;
            padding: 50px 20px;
            background: var(--card-bg);
            border-radius: 25px;
            margin-bottom: 30px;
            backdrop-filter: blur(20px);
            border: 2px solid var(--border-color);
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            position: relative;
            overflow: hidden;
        }
        
        .hero-header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(102,126,234,0.1) 0%, transparent 70%);
            animation: pulse-glow 4s ease-in-out infinite;
        }
        
        @keyframes pulse-glow {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }
        
        .hero-header h1 {
            font-size: 4em;
            margin-bottom: 20px;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            position: relative;
            z-index: 1;
            font-weight: 900;
            text-shadow: 0 0 30px rgba(102,126,234,0.5);
        }
        
        .hero-subtitle {
            font-size: 1.6em;
            margin: 15px 0;
            opacity: 0.95;
            position: relative;
            z-index: 1;
        }
        
        .hero-description {
            font-size: 1.1em;
            opacity: 0.85;
            max-width: 900px;
            margin: 15px auto;
            line-height: 1.6;
            position: relative;
            z-index: 1;
        }
        
        .theory-badge {
            display: inline-block;
            background: rgba(102,126,234,0.2);
            border: 2px solid var(--success-color);
            padding: 10px 20px;
            border-radius: 20px;
            margin: 10px 5px;
            font-size: 0.9em;
            font-weight: 600;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .panel {
            background: var(--card-bg);
            padding: 25px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            transition: all 0.3s;
        }
        
        .panel:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(102,126,234,0.3);
            border-color: rgba(102,126,234,0.5);
        }
        
        .panel h3 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.4em;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .bio-signature-panel {
            background: rgba(0,0,0,0.5);
            padding: 20px;
            border-radius: 12px;
            margin: 15px 0;
            border: 2px solid var(--success-color);
            box-shadow: 0 0 20px rgba(74,222,128,0.2);
        }
        
        .metric-row {
            display: flex;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 1.05em;
        }
        
        .metric-label {
            color: var(--music-color);
            font-weight: 600;
        }
        
        .metric-value {
            color: var(--success-color);
            font-family: 'Courier New', monospace;
            font-size: 1.15em;
            font-weight: 700;
        }
        
        .huge-value {
            font-size: 2.8em;
            color: var(--success-color);
            text-align: center;
            margin: 20px 0;
            text-shadow: 0 0 20px rgba(74,222,128,0.5);
            font-weight: 900;
        }
        
        .control-button {
            background: var(--primary-gradient);
            color: white;
            border: none;
            padding: 20px 40px;
            border-radius: 12px;
            font-size: 1.35em;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            margin: 10px 0;
            box-shadow: 0 8px 25px rgba(102,126,234,0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .control-button:hover:not(:disabled) {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 12px 35px rgba(102,126,234,0.7);
        }
        
        .control-button:active {
            transform: translateY(0);
        }
        
        .control-button.stop {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            box-shadow: 0 8px 25px rgba(245,87,108,0.5);
        }
        
        .control-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .psi-display {
            background: rgba(0,0,0,0.6);
            padding: 25px;
            border-radius: 15px;
            margin: 15px 0;
            border: 2px solid rgba(102,126,234,0.4);
        }
        
        .psi-meter {
            width: 100%;
            height: 40px;
            background: rgba(0,0,0,0.5);
            border-radius: 20px;
            overflow: hidden;
            margin: 15px 0;
            border: 2px solid rgba(255,255,255,0.2);
            position: relative;
        }
        
        .psi-bar {
            height: 100%;
            background: linear-gradient(90deg, #4ade80, #667eea, #f093fb, #fbbf24);
            transition: width 0.3s;
            box-shadow: 0 0 20px rgba(102,126,234,0.6);
            position: relative;
        }
        
        .psi-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer-flow 2s infinite;
        }
        
        @keyframes shimmer-flow {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .instrument-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .instrument-card {
            background: rgba(0,0,0,0.5);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .instrument-card:hover {
            border-color: rgba(102,126,234,0.5);
            transform: scale(1.05);
        }
        
        .instrument-card.active {
            border-color: var(--success-color);
            box-shadow: 0 0 25px rgba(74,222,128,0.4);
            animation: instrument-pulse 0.5s;
        }
        
        @keyframes instrument-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .instrument-icon {
            font-size: 3em;
            margin-bottom: 12px;
            filter: drop-shadow(0 0 10px rgba(102,126,234,0.5));
        }
        
        .instrument-name {
            font-weight: 700;
            margin-bottom: 10px;
            color: var(--music-color);
            font-size: 1.1em;
        }
        
        .volume-control {
            width: 100%;
            margin: 10px 0;
        }
        
        .mute-toggle {
            background: rgba(102,126,234,0.3);
            border: 2px solid rgba(102,126,234,0.5);
            color: white;
            padding: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95em;
            transition: all 0.3s;
            font-weight: 600;
        }
        
        .mute-toggle.muted {
            background: rgba(245,87,108,0.5);
            border-color: var(--error-color);
        }
        
        .visualizer-panel {
            background: rgba(0,0,0,0.7);
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 25px;
            border: 1px solid var(--border-color);
        }
        
        canvas {
            width: 100%;
            border-radius: 12px;
            background: linear-gradient(180deg, #0a0a0a 0%, #1a1a2e 100%);
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
        }
        
        .token-memory {
            background: rgba(0,0,0,0.6);
            padding: 20px;
            border-radius: 12px;
            margin: 15px 0;
            max-height: 300px;
            overflow-y: auto;
            border: 2px solid rgba(102,126,234,0.3);
        }
        
        .token-entry {
            padding: 10px;
            margin: 8px 0;
            background: rgba(102,126,234,0.1);
            border-left: 4px solid var(--music-color);
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            animation: token-appear 0.3s ease-out;
        }
        
        @keyframes token-appear {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        .log-panel {
            background: rgba(0,0,0,0.8);
            padding: 25px;
            border-radius: 15px;
            max-height: 450px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            border: 1px solid var(--border-color);
        }
        
        .log-entry {
            padding: 10px;
            margin: 6px 0;
            border-left: 4px solid #667eea;
            animation: log-slide 0.3s ease-out;
        }
        
        @keyframes log-slide {
            from { opacity: 0; transform: translateX(-15px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        .log-entry.info { color: #60a5fa; border-left-color: #60a5fa; }
        .log-entry.success { color: var(--success-color); border-left-color: var(--success-color); }
        .log-entry.warning { color: var(--warning-color); border-left-color: var(--warning-color); }
        .log-entry.music { color: var(--music-color); border-left-color: var(--music-color); }
        .log-entry.error { color: var(--error-color); border-left-color: var(--error-color); }
        .log-entry.phi { color: #fbbf24; border-left-color: #fbbf24; font-weight: 700; }
        
        .genre-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 12px;
            margin-top: 15px;
        }
        
        .genre-btn {
            background: rgba(102,126,234,0.2);
            border: 2px solid rgba(102,126,234,0.4);
            color: white;
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 700;
            text-align: center;
            font-size: 1.05em;
        }
        
        .genre-btn:hover {
            background: rgba(102,126,234,0.4);
            transform: scale(1.08);
        }
        
        .genre-btn.active {
            background: var(--primary-gradient);
            border-color: var(--success-color);
            box-shadow: 0 0 20px rgba(74,222,128,0.5);
        }
        
        @media (max-width: 1200px) {
            .main-grid { grid-template-columns: 1fr 1fr; }
            .hero-header h1 { font-size: 3em; }
        }
        
        @media (max-width: 768px) {
            .main-grid { grid-template-columns: 1fr; }
            .hero-header h1 { font-size: 2.2em; }
        }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 10px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #764ba2, #f093fb);
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Hero Header -->
        <div class="hero-header">
            <h1>🌌 ULTIMATE AI BAND CONDUCTOR 🌌</h1>
            <p class="hero-subtitle">Real-Time Vibrational Intelligence Music System</p>
            <p class="hero-description">
                The world's first AI band powered by <strong>Unified Theory of Vibrational Information Architecture</strong>.
                Uses bio-frequency matching, Light Token generation, stochastic resonance, ψ-driven composition,
                and φ-harmonic series to create music that resonates with YOUR vibrational essence.
            </p>
            <div style="margin-top: 20px;">
                <span class="theory-badge">🧬 Bio-Frequency Matching</span>
                <span class="theory-badge">💎 Light Token Generation</span>
                <span class="theory-badge">📊 Spectral Analysis</span>
                <span class="theory-badge">🌀 Stochastic Resonance</span>
                <span class="theory-badge">φ Golden Ratio Harmonics</span>
                <span class="theory-badge">ψ Information Density</span>
                <span class="theory-badge">🔮 Lorenz Chaos</span>
            </div>
        </div>
        
        <!-- Main Control Grid -->
        <div class="main-grid">
            <!-- Bio-Frequency Signature -->
            <div class="panel">
                <h3>🧬 Bio-Frequency Signature</h3>
                <div class="bio-signature-panel">
                    <div class="huge-value" id="bioFrequency">-- Hz</div>
                    <div style="text-align: center; opacity: 0.8; margin-bottom: 15px;">Your Fundamental Frequency</div>
                    
                    <div class="metric-row">
                        <span class="metric-label">Detected Note:</span>
                        <span class="metric-value" id="detectedNote">--</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Spectral Centroid:</span>
                        <span class="metric-value" id="spectralCentroid">-- Hz</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Spectral Spread:</span>
                        <span class="metric-value" id="spectralSpread">--</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Harmonic Richness:</span>
                        <span class="metric-value" id="harmonicRichness">--</span>
                    </div>
                </div>
            </div>
            
            <!-- Musical Analysis -->
            <div class="panel">
                <h3>🎵 Musical Intelligence</h3>
                <div class="bio-signature-panel">
                    <div class="metric-row">
                        <span class="metric-label">Detected Key:</span>
                        <span class="metric-value" id="detectedKey">C Major</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Tempo (BPM):</span>
                        <span class="metric-value" id="detectedTempo">120</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Energy Level:</span>
                        <span class="metric-value" id="energyLevel">Medium</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">φ-Harmonic Count:</span>
                        <span class="metric-value" id="phiHarmonicCount">0</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Light Tokens:</span>
                        <span class="metric-value" id="lightTokenCount">0</span>
                    </div>
                </div>
            </div>
            
            <!-- Psi Information Density -->
            <div class="panel">
                <h3>ψ Information Density</h3>
                <div class="psi-display">
                    <div class="huge-value" id="psiValue">0.000</div>
                    <div style="text-align: center; opacity: 0.8; margin-bottom: 15px;">Musical Complexity Measure</div>
                    
                    <div class="psi-meter">
                        <div class="psi-bar" id="psiBar" style="width: 0%"></div>
                    </div>
                    
                    <div class="metric-row">
                        <span class="metric-label">φ-Energy Term:</span>
                        <span class="metric-value" id="phiEnergy">0.0000</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Chaos (λ):</span>
                        <span class="metric-value" id="chaosParam">0.000</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Rhythm Integral:</span>
                        <span class="metric-value" id="rhythmIntegral">0.000</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Harmonic Ω:</span>
                        <span class="metric-value" id="harmonicOmega">0.000</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Main Controls -->
        <div class="main-grid">
            <div class="panel">
                <h3>🎛️ Band Controls</h3>
                <button class="control-button" id="startBtn" onclick="startBand()">
                    🎤 Start Vibrational Sync
                </button>
                <button class="control-button stop" id="stopBtn" onclick="stopBand()" disabled>
                    ⏹ Stop Band
                </button>
                <button class="control-button" style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);" onclick="testBand()">
                    🔊 Test All Instruments
                </button>
            </div>
            
            <div class="panel">
                <h3>🎨 Musical Style</h3>
                <div class="genre-grid">
                    <div class="genre-btn active" data-genre="phi-natural" onclick="selectGenre('phi-natural')">
                        φ Natural
                    </div>
                    <div class="genre-btn" data-genre="rock" onclick="selectGenre('rock')">
                        🎸 Rock
                    </div>
                    <div class="genre-btn" data-genre="jazz" onclick="selectGenre('jazz')">
                        🎺 Jazz
                    </div>
                    <div class="genre-btn" data-genre="funk" onclick="selectGenre('funk')">
                        🕺 Funk
                    </div>
                    <div class="genre-btn" data-genre="cosmic" onclick="selectGenre('cosmic')">
                        🌌 Cosmic
                    </div>
                    <div class="genre-btn" data-genre="chaos" onclick="selectGenre('chaos')">
                        🌀 Chaos
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <h3>💎 Spectral Memory</h3>
                <div class="token-memory" id="tokenMemory">
                    <div style="text-align: center; opacity: 0.7; padding: 20px;">
                        Light Tokens will appear here as the system learns your patterns...
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Instrument Mixer -->
        <div class="panel">
            <h3>🎚️ Professional Mixer</h3>
            <div class="instrument-grid">
                <div class="instrument-card" id="drums-card">
                    <div class="instrument-icon">🥁</div>
                    <div class="instrument-name">Drums</div>
                    <input type="range" class="volume-control" id="drums-vol" min="0" max="100" value="80">
                    <button class="mute-toggle" onclick="toggleMute('drums')">Mute</button>
                </div>
                
                <div class="instrument-card" id="bass-card">
                    <div class="instrument-icon">🎸</div>
                    <div class="instrument-name">Bass</div>
                    <input type="range" class="volume-control" id="bass-vol" min="0" max="100" value="70">
                    <button class="mute-toggle" onclick="toggleMute('bass')">Mute</button>
                </div>
                
                <div class="instrument-card" id="guitar-card">
                    <div class="instrument-icon">🎸</div>
                    <div class="instrument-name">Guitar</div>
                    <input type="range" class="volume-control" id="guitar-vol" min="0" max="100" value="60">
                    <button class="mute-toggle" onclick="toggleMute('guitar')">Mute</button>
                </div>
                
                <div class="instrument-card" id="piano-card">
                    <div class="instrument-icon">🎹</div>
                    <div class="instrument-name">Piano</div>
                    <input type="range" class="volume-control" id="piano-vol" min="0" max="100" value="65">
                    <button class="mute-toggle" onclick="toggleMute('piano')">Mute</button>
                </div>
                
                <div class="instrument-card" id="strings-card">
                    <div class="instrument-icon">🎻</div>
                    <div class="instrument-name">Strings</div>
                    <input type="range" class="volume-control" id="strings-vol" min="0" max="100" value="50">
                    <button class="mute-toggle" onclick="toggleMute('strings')">Mute</button>
                </div>
                
                <div class="instrument-card" id="pads-card">
                    <div class="instrument-icon">🌊</div>
                    <div class="instrument-name">Pads</div>
                    <input type="range" class="volume-control" id="pads-vol" min="0" max="100" value="40">
                    <button class="mute-toggle" onclick="toggleMute('pads')">Mute</button>
                </div>
            </div>
        </div>
        
        <!-- Visualizers -->
        <div class="visualizer-panel">
            <h3 style="margin-bottom: 20px;">📊 Spectral Analysis with Bio-Frequency Marker</h3>
            <canvas id="spectrumCanvas" height="250"></canvas>
        </div>
        
        <div class="visualizer-panel">
            <h3 style="margin-bottom: 20px;">〰️ Waveform Display</h3>
            <canvas id="waveformCanvas" height="200"></canvas>
        </div>
        
        <!-- Activity Log -->
        <div class="panel">
            <h3>📝 System Activity Log</h3>
            <div class="log-panel" id="logPanel">
                <div class="log-entry success">[System] ULTIMATE AI Band Conductor v4.0 initialized</div>
                <div class="log-entry info">[Theory] Unified Vibrational Information Architecture loaded</div>
                <div class="log-entry phi">[Math] Golden Ratio (φ = 1.618033988749895) active</div>
                <div class="log-entry success">[System] All synthesis engines ready</div>
                <div class="log-entry music">[System] Ready to create vibrational harmony with you!</div>
            </div>
        </div>
    </div>
    
    <script>
        // =====================================================================
        // ULTIMATE AI BAND CONDUCTOR v4.0
        // Complete Integration of Vibrational Information Theory
        // Author: Cory Shane Davis
        // Date: October 28, 2025
        // =====================================================================
        
        class LightToken {
            constructor(audioSegment, sampleRate, pitchFrequency, timestamp) {
                this.id = Math.random().toString(36).substr(2, 9);
                this.timestamp = timestamp;
                
                // Layer 1: Semantic (Musical meaning)
                this.pitch = pitchFrequency;
                this.note = this.frequencyToNote(pitchFrequency);
                this.duration = audioSegment.length / sampleRate;
                
                // Layer 2: Perceptual (Timbre)
                this.rms = this.calculateRMS(audioSegment);
                this.zcr = this.calculateZCR(audioSegment);
                
                // Layer 3: Spectral Signature (INNOVATION)
                this.spectralSignature = this.computeSpectralSignature(audioSegment);
                this.spectralCentroid = this.spectralSignature.centroid;
                this.spectralSpread = this.spectralSignature.spread;
            }
            
            calculateRMS(buffer) {
                let sum = 0;
                for (let i = 0; i < buffer.length; i++) {
                    sum += buffer[i] * buffer[i];
                }
                return Math.sqrt(sum / buffer.length);
            }
            
            calculateZCR(buffer) {
                let crossings = 0;
                for (let i = 1; i < buffer.length; i++) {
                    if ((buffer[i-1] >= 0 && buffer[i] < 0) || (buffer[i-1] < 0 && buffer[i] >= 0)) {
                        crossings++;
                    }
                }
                return crossings / buffer.length;
            }
            
            computeSpectralSignature(buffer) {
                // Simplified spectral analysis
                const fft = this.simpleFFT(buffer);
                const magnitudes = fft.map(c => Math.sqrt(c.real * c.real + c.imag * c.imag));
                
                // Spectral centroid
                let weightedSum = 0;
                let totalMag = 0;
                for (let i = 0; i < magnitudes.length; i++) {
                    weightedSum += i * magnitudes[i];
                    totalMag += magnitudes[i];
                }
                const centroid = weightedSum / (totalMag || 1);
                
                // Spectral spread
                let variance = 0;
                for (let i = 0; i < magnitudes.length; i++) {
                    const diff = i - centroid;
                    variance += diff * diff * magnitudes[i];
                }
                const spread = Math.sqrt(variance / (totalMag || 1));
                
                return { centroid, spread, magnitudes };
            }
            
            simpleFFT(signal) {
                // Simplified DFT (use FFT library in production)
                const N = Math.min(signal.length, 512);
                const result = [];
                
                for (let k = 0; k < N/2; k++) {
                    let real = 0;
                    let imag = 0;
                    
                    for (let n = 0; n < N; n++) {
                        const angle = (-2 * Math.PI * k * n) / N;
                        real += signal[n] * Math.cos(angle);
                        imag += signal[n] * Math.sin(angle);
                    }
                    
                    result.push({ real, imag });
                }
                
                return result;
            }
            
            frequencyToNote(frequency) {
                const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                const noteNum = 12 * (Math.log(frequency / 440) / Math.log(2));
                const noteIndex = Math.round(noteNum) + 69;
                const note = noteNames[noteIndex % 12];
                const octave = Math.floor(noteIndex / 12) - 1;
                return `${note}${octave}`;
            }
            
            spectralSimilarity(other) {
                // Compare spectral signatures
                const mag1 = this.spectralSignature.magnitudes;
                const mag2 = other.spectralSignature.magnitudes;
                
                const minLen = Math.min(mag1.length, mag2.length);
                let dotProduct = 0;
                let norm1 = 0;
                let norm2 = 0;
                
                for (let i = 0; i < minLen; i++) {
                    dotProduct += mag1[i] * mag2[i];
                    norm1 += mag1[i] * mag1[i];
                    norm2 += mag2[i] * mag2[i];
                }
                
                return dotProduct / (Math.sqrt(norm1 * norm2) || 1);
            }
        }
        
        class UltimateAIBandConductor {
            constructor() {
                this.audioContext = null;
                this.analyzer = null;
                this.microphone = null;
                this.isActive = false;
                
                // Mathematical constants
                this.PHI = 1.618033988749895;  // Golden Ratio
                this.C_SOUND = 343.0;  // Speed of sound (m/s)
                
                // Bio-frequency signature
                this.bioSignature = {
                    fundamental: null,
                    spectralCentroid: null,
                    spectralSpread: null,
                    harmonicRichness: null,
                    lastUpdate: null
                };
                
                // Light Token memory
                this.lightTokens = [];
                this.maxTokens = 50;
                
                // Psi components
                this.psi = 0;
                this.psiComponents = {
                    phiEnergy: 0,
                    chaos: 0,
                    rhythmIntegral: 0,
                    harmonicOmega: 0
                };
                
                // Musical state
                this.currentPitch = null;
                this.currentNote = null;
                this.currentKey = 'C';
                this.currentMode = 'major';
                this.currentTempo = 120;
                this.currentGenre = 'phi-natural';
                this.energyLevel = 0;
                
                // φ-Harmonic series
                this.phiHarmonics = [];
                
                // Pitch history for key detection
                this.pitchHistory = [];
                this.maxPitchHistory = 50;
                
                // Lorenz state for chaos
                this.lorenzState = { x: 1, y: 1, z: 1 };
                
                // Instruments
                this.instruments = {
                    drums: { gain: null, enabled: true, volume: 0.8, active: false },
                    bass: { gain: null, enabled: true, volume: 0.7, active: false },
                    guitar: { gain: null, enabled: true, volume: 0.6, active: false },
                    piano: { gain: null, enabled: true, volume: 0.65, active: false },
                    strings: { gain: null, enabled: true, volume: 0.5, active: false },
                    pads: { gain: null, enabled: true, volume: 0.4, active: false }
                };
                
                // Master effects
                this.masterCompressor = null;
                this.masterGain = null;
                
                // Timing
                this.lastDrumBeat = 0;
                this.lastBassNote = 0;
                this.lastChordPlay = 0;
                this.beatInterval = 500;
                
                this.noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                
                this.initAudio();
            }
            
            async initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Analyzer
                    this.analyzer = this.audioContext.createAnalyser();
                    this.analyzer.fftSize = 8192;  // Higher resolution
                    this.analyzer.smoothingTimeConstant = 0.8;
                    
                    // Master chain
                    this.masterCompressor = this.audioContext.createDynamicsCompressor();
                    this.masterCompressor.threshold.value = -20;
                    this.masterCompressor.knee.value = 30;
                    this.masterCompressor.ratio.value = 12;
                    this.masterCompressor.attack.value = 0.003;
                    this.masterCompressor.release.value = 0.25;
                    
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.gain.value = 0.6;
                    
                    this.masterCompressor.connect(this.masterGain);
                    this.masterGain.connect(this.audioContext.destination);
                    
                    // Initialize instruments
                    for (let inst in this.instruments) {
                        this.instruments[inst].gain = this.audioContext.createGain();
                        this.instruments[inst].gain.gain.value = this.instruments[inst].volume;
                        this.instruments[inst].gain.connect(this.masterCompressor);
                    }
                    
                    this.log('🌌 Audio system initialized with vibrational intelligence', 'success');
                    this.log('φ Golden Ratio: 1.618033988749895', 'phi');
                    
                } catch (error) {
                    this.log(`❌ Audio init failed: ${error.message}`, 'error');
                }
            }
            
            async startBand() {
                if (this.isActive) return;
                
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        } 
                    });
                    
                    this.microphone = this.audioContext.createMediaStreamSource(stream);
                    this.microphone.connect(this.analyzer);
                    
                    this.isActive = true;
                    
                    this.log('🎤 Microphone connected - extracting bio-frequency signature...', 'success');
                    this.log('🧬 Listening for your vibrational essence...', 'music');
                    
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('stopBtn').disabled = false;
                    
                    // Start loops
                    this.mainLoop();
                    this.visualizationLoop();
                    
                } catch (error) {
                    this.log(`❌ Failed to start: ${error.message}`, 'error');
                }
            }
            
            mainLoop() {
                if (!this.isActive) return;
                
                // Get audio data
                const bufferLength = this.analyzer.fftSize;
                const timeDomainData = new Float32Array(bufferLength);
                this.analyzer.getFloatTimeDomainData(timeDomainData);
                
                // Detect pitch with advanced algorithm
                this.currentPitch = this.detectPitchYIN(timeDomainData);
                
                if (this.currentPitch && this.currentPitch > 50 && this.currentPitch < 1000) {
                    this.currentNote = this.frequencyToNote(this.currentPitch);
                    this.pitchHistory.push(this.currentPitch);
                    
                    if (this.pitchHistory.length > this.maxPitchHistory) {
                        this.pitchHistory.shift();
                    }
                    
                    // Update bio-signature
                    if (!this.bioSignature.fundamental || Math.random() < 0.1) {
                        this.updateBioSignature(timeDomainData);
                    }
                    
                    // Generate φ-harmonics from bio-signature
                    if (this.bioSignature.fundamental && Math.random() < 0.05) {
                        this.generatePhiHarmonics();
                    }
                    
                    // Create Light Token
                    if (Math.random() < 0.1) {
                        this.createLightToken(timeDomainData);
                    }
                    
                    // Update UI
                    document.getElementById('bioFrequency').textContent = `${this.currentPitch.toFixed(1)} Hz`;
                    document.getElementById('detectedNote').textContent = this.currentNote;
                }
                
                // Key detection
                if (Math.random() < 0.02 && this.pitchHistory.length > 10) {
                    this.detectKey();
                }
                
                // Energy calculation
                this.energyLevel = this.calculateEnergy(timeDomainData);
                const energyText = this.energyLevel < 0.3 ? 'Low' : this.energyLevel < 0.6 ? 'Medium' : 'High';
                document.getElementById('energyLevel').textContent = energyText;
                
                // Calculate ψ (psi) - CORE INNOVATION
                this.calculatePsi();
                
                // Generate music based on ψ and genre
                this.generateMusic();
                
                // Continue loop
                setTimeout(() => this.mainLoop(), 50);
            }
            
            detectPitchYIN(buffer) {
                // YIN algorithm - superior pitch detection
                const threshold = 0.15;
                const bufferSize = buffer.length;
                const yinBuffer = new Float32Array(bufferSize / 2);
                
                // Step 1: Difference function
                for (let tau = 0; tau < yinBuffer.length; tau++) {
                    yinBuffer[tau] = 0;
                    for (let i = 0; i < yinBuffer.length; i++) {
                        const delta = buffer[i] - buffer[i + tau];
                        yinBuffer[tau] += delta * delta;
                    }
                }
                
                // Step 2: Cumulative mean normalized difference
                yinBuffer[0] = 1;
                let runningSum = 0;
                for (let tau = 1; tau < yinBuffer.length; tau++) {
                    runningSum += yinBuffer[tau];
                    yinBuffer[tau] *= tau / runningSum;
                }
                
                // Step 3: Absolute threshold
                let tau = -1;
                for (let i = 2; i < yinBuffer.length; i++) {
                    if (yinBuffer[i] < threshold) {
                        while (i + 1 < yinBuffer.length && yinBuffer[i + 1] < yinBuffer[i]) {
                            i++;
                        }
                        tau = i;
                        break;
                    }
                }
                
                if (tau === -1) return null;
                
                // Step 4: Parabolic interpolation
                let betterTau = tau;
                if (tau > 0 && tau < yinBuffer.length - 1) {
                    const s0 = yinBuffer[tau - 1];
                    const s1 = yinBuffer[tau];
                    const s2 = yinBuffer[tau + 1];
                    betterTau = tau + (s2 - s0) / (2 * (2 * s1 - s2 - s0));
                }
                
                return this.audioContext.sampleRate / betterTau;
            }
            
            updateBioSignature(buffer) {
                this.bioSignature.fundamental = this.currentPitch;
                
                // Spectral analysis
                const fft = this.computeFFT(buffer);
                const magnitudes = fft.map(c => Math.sqrt(c.real * c.real + c.imag * c.imag));
                
                // Spectral centroid
                let weightedSum = 0;
                let totalMag = 0;
                for (let i = 0; i < magnitudes.length; i++) {
                    weightedSum += i * magnitudes[i];
                    totalMag += magnitudes[i];
                }
                this.bioSignature.spectralCentroid = (weightedSum / (totalMag || 1)) * 
                    (this.audioContext.sampleRate / this.analyzer.fftSize);
                
                // Spectral spread
                const centroidBin = (this.bioSignature.spectralCentroid * this.analyzer.fftSize) / 
                    this.audioContext.sampleRate;
                let variance = 0;
                for (let i = 0; i < magnitudes.length; i++) {
                    const diff = i - centroidBin;
                    variance += diff * diff * magnitudes[i];
                }
                this.bioSignature.spectralSpread = Math.sqrt(variance / (totalMag || 1));
                
                // Harmonic richness (count of strong harmonics)
                const threshold = Math.max(...magnitudes) * 0.1;
                this.bioSignature.harmonicRichness = magnitudes.filter(m => m > threshold).length;
                
                this.bioSignature.lastUpdate = Date.now();
                
                // Update UI
                document.getElementById('spectralCentroid').textContent = 
                    `${this.bioSignature.spectralCentroid.toFixed(1)} Hz`;
                document.getElementById('spectralSpread').textContent = 
                    this.bioSignature.spectralSpread.toFixed(2);
                document.getElementById('harmonicRichness').textContent = 
                    this.bioSignature.harmonicRichness;
                
                this.log(`🧬 Bio-signature updated: ${this.bioSignature.fundamental.toFixed(1)} Hz`, 'music');
            }
            
            generatePhiHarmonics() {
                if (!this.bioSignature.fundamental) return;
                
                const fundamental = this.bioSignature.fundamental;
                this.phiHarmonics = [];
                
                const numHarmonics = 12;
                
                for (let i = 0; i < numHarmonics; i++) {
                    // φ-based frequency generation
                    const exponent = i - (numHarmonics / 2);
                    let freq = fundamental * Math.pow(this.PHI, exponent);
                    
                    // Fold into musical range
                    while (freq > fundamental * 4) freq /= 2;
                    while (freq < fundamental / 2) freq *= 2;
                    
                    // Quantize to 12-TET
                    const midi = 69 + 12 * Math.log2(freq / 440);
                    const quantizedMidi = Math.round(midi);
                    const finalFreq = 440 * Math.pow(2, (quantizedMidi - 69) / 12);
                    
                    this.phiHarmonics.push(finalFreq);
                }
                
                this.phiHarmonics.sort((a, b) => a - b);
                
                document.getElementById('phiHarmonicCount').textContent = this.phiHarmonics.length;
                
                this.log(`φ Generated ${this.phiHarmonics.length} golden-ratio harmonics`, 'phi');
            }
            
            createLightToken(buffer) {
                if (!this.currentPitch) return;
                
                const token = new LightToken(
                    buffer.slice(0, 2048),
                    this.audioContext.sampleRate,
                    this.currentPitch,
                    Date.now()
                );
                
                this.lightTokens.push(token);
                
                if (this.lightTokens.length > this.maxTokens) {
                    this.lightTokens.shift();
                }
                
                document.getElementById('lightTokenCount').textContent = this.lightTokens.length;
                
                // Display in UI
                this.displayToken(token);
                
                // Check for spectral similarities
                if (this.lightTokens.length > 2) {
                    const prevToken = this.lightTokens[this.lightTokens.length - 2];
                    const similarity = token.spectralSimilarity(prevToken);
                    
                    if (similarity > 0.8) {
                        this.log(`💎 High spectral similarity detected: ${(similarity * 100).toFixed(1)}%`, 'music');
                    }
                }
            }
            
            displayToken(token) {
                const tokenMemory = document.getElementById('tokenMemory');
                const entry = document.createElement('div');
                entry.className = 'token-entry';
                entry.innerHTML = `
                    <strong>${token.note}</strong> @ ${token.pitch.toFixed(1)}Hz | 
                    Centroid: ${token.spectralCentroid.toFixed(1)} | 
                    Spread: ${token.spectralSpread.toFixed(1)} | 
                    RMS: ${token.rms.toFixed(3)}
                `;
                
                if (tokenMemory.firstChild && tokenMemory.firstChild.style) {
                    tokenMemory.firstChild.remove();
                }
                
                tokenMemory.insertBefore(entry, tokenMemory.firstChild);
                
                // Keep only last 10 displayed
                while (tokenMemory.children.length > 10) {
                    tokenMemory.removeChild(tokenMemory.lastChild);
                }
            }
            
            calculatePsi() {
                // ψ = [(φ × E)/c² + λ + ∫rhythm + Ω×E] / ρ_ref
                
                // Get current energy
                const bufferLength = this.analyzer.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                this.analyzer.getByteFrequencyData(dataArray);
                
                const rmsEnergy = Math.sqrt(
                    dataArray.reduce((sum, val) => sum + val * val, 0) / bufferLength
                ) / 255.0;
                
                // Component 1: φ-Energy
                const phiEnergy = (this.PHI * rmsEnergy) / (this.C_SOUND * this.C_SOUND);
                this.psiComponents.phiEnergy = phiEnergy;
                
                // Component 2: Chaos (λ) - use Lorenz attractor
                this.updateLorenzState();
                const chaos = Math.abs(this.lorenzState.x) / 30;  // Normalize
                this.psiComponents.chaos = chaos;
                
                // Component 3: Rhythm integral
                const activeInstruments = Object.values(this.instruments).filter(i => i.active).length;
                this.psiComponents.rhythmIntegral += activeInstruments * 0.02;
                this.psiComponents.rhythmIntegral *= 0.98;  // Decay
                
                // Component 4: Harmonic connectivity
                const harmonicOmega = (this.phiHarmonics.length / 12) * rmsEnergy;
                this.psiComponents.harmonicOmega = harmonicOmega;
                
                // Total ψ
                this.psi = phiEnergy + chaos + this.psiComponents.rhythmIntegral + harmonicOmega;
                
                // Update UI
                document.getElementById('psiValue').textContent = this.psi.toFixed(3);
                document.getElementById('phiEnergy').textContent = phiEnergy.toFixed(4);
                document.getElementById('chaosParam').textContent = chaos.toFixed(3);
                document.getElementById('rhythmIntegral').textContent = 
                    this.psiComponents.rhythmIntegral.toFixed(3);
                document.getElementById('harmonicOmega').textContent = harmonicOmega.toFixed(3);
                
                const percentage = Math.min(100, (this.psi / 1.5) * 100);
                document.getElementById('psiBar').style.width = percentage + '%';
            }
            
            updateLorenzState() {
                // Lorenz attractor for chaos generation
                const sigma = 10;
                const rho = 28;
                const beta = 8/3;
                const dt = 0.01;
                
                const dx = sigma * (this.lorenzState.y - this.lorenzState.x);
                const dy = this.lorenzState.x * (rho - this.lorenzState.z) - this.lorenzState.y;
                const dz = this.lorenzState.x * this.lorenzState.y - beta * this.lorenzState.z;
                
                this.lorenzState.x += dx * dt;
                this.lorenzState.y += dy * dt;
                this.lorenzState.z += dz * dt;
            }
            
            generateMusic() {
                if (!this.currentPitch) return;
                
                const now = Date.now();
                this.beatInterval = (60000 / this.currentTempo);
                
                // Psi-driven composition decisions
                if (this.psi < 0.3) {
                    // Too sparse - add instruments
                    if (now - this.lastChordPlay >= this.beatInterval * 2) {
                        this.playChordProgression();
                        this.lastChordPlay = now;
                    }
                } else if (this.psi > 0.7) {
                    // Too dense - simplify (skip some beats)
                    if (Math.random() > 0.3) return;
                }
                
                // Drums - tempo-locked
                if (now - this.lastDrumBeat >= this.beatInterval) {
                    this.playDrums();
                    this.lastDrumBeat = now;
                }
                
                // Bass - follows φ-harmonics
                if (now - this.lastBassNote >= this.beatInterval) {
                    this.playBass();
                    this.lastBassNote = now;
                }
                
                // Ambient pads (continuous)
                if (Math.random() < 0.01) {
                    this.playAmbientPad();
                }
            }
            
            playChordProgression() {
                if (!this.phiHarmonics || this.phiHarmonics.length < 3) return;
                
                // Select φ-harmonic frequencies for chord
                const chord = [];
                const indices = [0, 2, 4];  // Root, third, fifth from φ series
                
                for (let idx of indices) {
                    if (idx < this.phiHarmonics.length) {
                        chord.push(this.phiHarmonics[idx]);
                    }
                }
                
                // Play on piano and guitar
                if (this.instruments.piano.enabled && chord.length > 0) {
                    this.playPianoChord(chord);
                }
                
                if (this.instruments.guitar.enabled && chord.length > 0) {
                    this.playGuitarChord(chord);
                }
                
                this.log(`🎹 Chord: ${chord.map(f => this.frequencyToNote(f)).join(', ')}`, 'music');
            }
            
            // [All the previous instrument synthesis methods remain the same]
            // playDrums, playKick, playSnare, playHiHat, playBass, etc.
            // [Copying from previous implementation...]
            
            playDrums() {
                if (!this.instruments.drums.enabled) return;
                
                this.playKick();
                this.playHiHat();
                setTimeout(() => this.playSnare(), this.beatInterval / 2);
                setTimeout(() => this.playHiHat(), this.beatInterval / 2);
                
                this.instruments.drums.active = true;
                document.getElementById('drums-card').classList.add('active');
                setTimeout(() => {
                    this.instruments.drums.active = false;
                    document.getElementById('drums-card').classList.remove('active');
                }, 100);
            }
            
            playKick(velocity = 0.8) {
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                const now = this.audioContext.currentTime;
                
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
                
                gain.gain.setValueAtTime(velocity, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                
                osc.connect(gain);
                gain.connect(this.instruments.drums.gain);
                
                osc.start(now);
                osc.stop(now + 0.5);
            }
            
            playSnare(velocity = 0.6) {
                const bufferSize = this.audioContext.sampleRate * 0.2;
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const output = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize / 5));
                }
                
                const noise = this.audioContext.createBufferSource();
                noise.buffer = buffer;
                
                const filter = this.audioContext.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 1000;
                
                const gain = this.audioContext.createGain();
                gain.gain.value = velocity;
                
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.instruments.drums.gain);
                
                noise.start();
            }
            
            playHiHat(velocity = 0.3) {
                const bufferSize = this.audioContext.sampleRate * 0.05;
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const output = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize / 10));
                }
                
                const noise = this.audioContext.createBufferSource();
                noise.buffer = buffer;
                
                const filter = this.audioContext.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 7000;
                
                const gain = this.audioContext.createGain();
                gain.gain.value = velocity;
                
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.instruments.drums.gain);
                
                noise.start();
            }
            
            playBass() {
                if (!this.instruments.bass.enabled || !this.phiHarmonics.length) return;
                
                // Use lowest φ-harmonic as bass root
                let bassFreq = this.phiHarmonics[0];
                while (bassFreq > 100) bassFreq /= 2;
                
                const osc = this.audioContext.createOscillator();
                const filter = this.audioContext.createBiquadFilter();
                const gain = this.audioContext.createGain();
                
                osc.type = 'sawtooth';
                osc.frequency.value = bassFreq;
                
                filter.type = 'lowpass';
                filter.frequency.value = 800;
                filter.Q.value = 3;
                
                const now = this.audioContext.currentTime;
                const duration = this.beatInterval / 1000;
                
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.4, now + 0.05);
                gain.gain.setValueAtTime(0.4, now + duration - 0.1);
                gain.gain.linearRampToValueAtTime(0, now + duration);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.instruments.bass.gain);
                
                osc.start(now);
                osc.stop(now + duration);
                
                this.instruments.bass.active = true;
                document.getElementById('bass-card').classList.add('active');
                setTimeout(() => {
                    this.instruments.bass.active = false;
                    document.getElementById('bass-card').classList.remove('active');
                }, 200);
            }
            
            playPianoChord(frequencies) {
                frequencies.forEach((freq, i) => {
                    setTimeout(() => this.playPianoNote(freq), i * 30);
                });
                
                this.instruments.piano.active = true;
                document.getElementById('piano-card').classList.add('active');
                setTimeout(() => {
                    this.instruments.piano.active = false;
                    document.getElementById('piano-card').classList.remove('active');
                }, 300);
            }
            
            playPianoNote(frequency, velocity = 0.3) {
                const carrier = this.audioContext.createOscillator();
                const modulator = this.audioContext.createOscillator();
                const modGain = this.audioContext.createGain();
                const gain = this.audioContext.createGain();
                
                carrier.frequency.value = frequency;
                modulator.frequency.value = frequency * 2;
                modGain.gain.value = frequency * 2;
                
                const now = this.audioContext.currentTime;
                
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(velocity, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(velocity * 0.3, now + 0.2);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 1.5);
                
                modulator.connect(modGain);
                modGain.connect(carrier.frequency);
                carrier.connect(gain);
                gain.connect(this.instruments.piano.gain);
                
                carrier.start(now);
                modulator.start(now);
                carrier.stop(now + 1.5);
                modulator.stop(now + 1.5);
            }
            
            playGuitarChord(frequencies) {
                frequencies.forEach((freq, i) => {
                    setTimeout(() => this.playGuitarString(freq), i * 20);
                });
                
                this.instruments.guitar.active = true;
                document.getElementById('guitar-card').classList.add('active');
                setTimeout(() => {
                    this.instruments.guitar.active = false;
                    document.getElementById('guitar-card').classList.remove('active');
                }, 300);
            }
            
            playGuitarString(frequency) {
                // Karplus-Strong
                const sampleRate = this.audioContext.sampleRate;
                const duration = 2.0;
                const delayLength = Math.round(sampleRate / frequency);
                
                const bufferSize = sampleRate * duration;
                const buffer = this.audioContext.createBuffer(1, bufferSize, sampleRate);
                const output = buffer.getChannelData(0);
                
                for (let i = 0; i < delayLength; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                
                for (let i = delayLength; i < bufferSize; i++) {
                    output[i] = 0.996 * 0.5 * (output[i - delayLength] + output[i - delayLength + 1]);
                }
                
                const source = this.audioContext.createBufferSource();
                source.buffer = buffer;
                
                const gain = this.audioContext.createGain();
                gain.gain.value = 0.2;
                
                source.connect(gain);
                gain.connect(this.instruments.guitar.gain);
                
                source.start();
            }
            
            playAmbientPad() {
                if (!this.instruments.pads.enabled || !this.phiHarmonics.length) return;
                
                // Long, sustained φ-harmonic pad
                const freq = this.phiHarmonics[Math.floor(Math.random() * this.phiHarmonics.length)];
                
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                const filter = this.audioContext.createBiquadFilter();
                
                osc.type = 'sine';
                osc.frequency.value = freq;
                
                filter.type = 'lowpass';
                filter.frequency.value = 2000;
                filter.Q.value = 1;
                
                const now = this.audioContext.currentTime;
                
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.15, now + 2);
                gain.gain.setValueAtTime(0.15, now + 8);
                gain.gain.linearRampToValueAtTime(0, now + 10);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.instruments.pads.gain);
                
                osc.start(now);
                osc.stop(now + 10);
                
                this.instruments.pads.active = true;
                document.getElementById('pads-card').classList.add('active');
                setTimeout(() => {
                    this.instruments.pads.active = false;
                    document.getElementById('pads-card').classList.remove('active');
                }, 500);
            }
            
            // Visualization
            visualizationLoop() {
                if (!this.isActive) return;
                
                this.drawSpectrum();
                this.drawWaveform();
                
                requestAnimationFrame(() => this.visualizationLoop());
            }
            
            drawSpectrum() {
                const canvas = document.getElementById('spectrumCanvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = canvas.offsetWidth;
                canvas.height = 250;
                
                const bufferLength = this.analyzer.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                this.analyzer.getByteFrequencyData(dataArray);
                
                ctx.fillStyle = 'rgb(10, 10, 10)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const barWidth = (canvas.width / bufferLength) * 2.5;
                let x = 0;
                
                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = (dataArray[i] / 255) * canvas.height * 0.9;
                    
                    const hue = (i / bufferLength) * 280 + 220;
                    const lightness = 35 + (dataArray[i] / 255) * 40;
                    ctx.fillStyle = `hsl(${hue}, 100%, ${lightness}%)`;
                    
                    ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                    x += barWidth + 1;
                }
                
                // Draw bio-frequency marker
                if (this.bioSignature.fundamental) {
                    const nyquist = this.audioContext.sampleRate / 2;
                    const freqIndex = (this.bioSignature.fundamental / nyquist) * bufferLength;
                    const markerX = (freqIndex / bufferLength) * canvas.width;
                    
                    ctx.strokeStyle = '#4ade80';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([8, 8]);
                    ctx.beginPath();
                    ctx.moveTo(markerX, 0);
                    ctx.lineTo(markerX, canvas.height);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    ctx.fillStyle = '#4ade80';
                    ctx.font = 'bold 16px monospace';
                    ctx.shadowColor = 'rgba(74, 222, 128, 0.8)';
                    ctx.shadowBlur = 10;
                    ctx.fillText(`🧬 ${this.bioSignature.fundamental.toFixed(1)}Hz`, markerX + 10, 25);
                    ctx.shadowBlur = 0;
                }
                
                // Draw φ-harmonics
                if (this.phiHarmonics.length > 0) {
                    ctx.strokeStyle = '#fbbf24';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    
                    for (let harmonic of this.phiHarmonics) {
                        const nyquist = this.audioContext.sampleRate / 2;
                        const freqIndex = (harmonic / nyquist) * bufferLength;
                        const hX = (freqIndex / bufferLength) * canvas.width;
                        
                        ctx.beginPath();
                        ctx.moveTo(hX, 0);
                        ctx.lineTo(hX, canvas.height);
                        ctx.stroke();
                    }
                    ctx.setLineDash([]);
                }
            }
            
            drawWaveform() {
                const canvas = document.getElementById('waveformCanvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = canvas.offsetWidth;
                canvas.height = 200;
                
                const bufferLength = this.analyzer.fftSize;
                const dataArray = new Uint8Array(bufferLength);
                this.analyzer.getByteTimeDomainData(dataArray);
                
                ctx.fillStyle = 'rgb(10, 10, 10)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.lineWidth = 3;
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(0.5, '#764ba2');
                gradient.addColorStop(1, '#f093fb');
                ctx.strokeStyle = gradient;
                
                ctx.beginPath();
                
                const sliceWidth = canvas.width / bufferLength;
                let x = 0;
                
                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * canvas.height / 2;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                    
                    x += sliceWidth;
                }
                
                ctx.stroke();
                
                // Center line
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, canvas.height / 2);
                ctx.lineTo(canvas.width, canvas.height / 2);
                ctx.stroke();
            }
            
            // Helper methods
            computeFFT(signal) {
                const N = Math.min(signal.length, 512);
                const result = [];
                
                for (let k = 0; k < N/2; k++) {
                    let real = 0;
                    let imag = 0;
                    
                    for (let n = 0; n < N; n++) {
                        const angle = (-2 * Math.PI * k * n) / N;
                        real += signal[n] * Math.cos(angle);
                        imag += signal[n] * Math.sin(angle);
                    }
                    
                    result.push({ real, imag });
                }
                
                return result;
            }
            
            frequencyToNote(frequency) {
                const noteNum = 12 * (Math.log(frequency / 440) / Math.log(2));
                const noteIndex = Math.round(noteNum) + 69;
                const note = this.noteNames[noteIndex % 12];
                const octave = Math.floor(noteIndex / 12) - 1;
                return `${note}${octave}`;
            }
            
            detectKey() {
                const pitchClasses = new Array(12).fill(0);
                
                for (let freq of this.pitchHistory) {
                    const noteNum = Math.round(12 * (Math.log(freq / 440) / Math.log(2))) + 69;
                    const pitchClass = noteNum % 12;
                    pitchClasses[pitchClass]++;
                }
                
                let maxCount = 0;
                let tonic = 0;
                
                for (let i = 0; i < 12; i++) {
                    if (pitchClasses[i] > maxCount) {
                        maxCount = pitchClasses[i];
                        tonic = i;
                    }
                }
                
                this.currentKey = this.noteNames[tonic];
                document.getElementById('detectedKey').textContent = `${this.currentKey} ${this.currentMode}`;
            }
            
            calculateEnergy(buffer) {
                let sum = 0;
                for (let i = 0; i < buffer.length; i++) {
                    sum += buffer[i] * buffer[i];
                }
                return Math.sqrt(sum / buffer.length);
            }
            
            // Controls
            stopBand() {
                this.isActive = false;
                
                if (this.microphone) {
                    this.microphone.disconnect();
                    this.microphone = null;
                }
                
                this.log('⏹ Band stopped - vibrational sync paused', 'warning');
                
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                
                for (let inst in this.instruments) {
                    document.getElementById(`${inst}-card`).classList.remove('active');
                }
            }
            
            testBand() {
                this.log('🔊 Testing all instruments with φ-harmonics...', 'info');
                
                // Generate test φ-harmonics
                this.bioSignature.fundamental = 440;
                this.generatePhiHarmonics();
                
                // Test drums
                this.playKick();
                setTimeout(() => this.playSnare(), 250);
                setTimeout(() => this.playHiHat(), 500);
                
                // Test bass
                setTimeout(() => this.playBass(), 750);
                
                // Test chord
                setTimeout(() => {
                    if (this.phiHarmonics.length >= 3) {
                        this.playChordProgression();
                    }
                }, 1000);
                
                setTimeout(() => {
                    this.log('✅ All instruments tested successfully!', 'success');
                }, 2000);
            }
            
            setGenre(genre) {
                this.currentGenre = genre;
                this.log(`🎨 Genre: ${genre.toUpperCase()}`, 'music');
                
                const tempos = {
                    'phi-natural': 120,
                    'rock': 120,
                    'jazz': 140,
                    'funk': 110,
                    'cosmic': 100,
                    'chaos': 160
                };
                
                this.currentTempo = tempos[genre] || 120;
                document.getElementById('detectedTempo').textContent = this.currentTempo;
            }
            
            toggleMute(instrument) {
                this.instruments[instrument].enabled = !this.instruments[instrument].enabled;
                
                const button = event.target;
                button.classList.toggle('muted');
                button.textContent = this.instruments[instrument].enabled ? 'Mute' : 'Unmuted';
                
                const status = this.instruments[instrument].enabled ? 'enabled' : 'muted';
                this.log(`🔇 ${instrument.toUpperCase()} ${status}`, 'info');
            }
            
            setVolume(instrument, value) {
                this.instruments[instrument].volume = value / 100;
                if (this.instruments[instrument].gain) {
                    this.instruments[instrument].gain.gain.value = this.instruments[instrument].volume;
                }
            }
            
            log(message, type = 'info') {
                const logPanel = document.getElementById('logPanel');
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                
                logPanel.appendChild(entry);
                logPanel.scrollTop = logPanel.scrollHeight;
                
                if (logPanel.children.length > 150) {
                    logPanel.removeChild(logPanel.firstChild);
                }
            }
        }
        
        // =====================================================================
        // GLOBAL INITIALIZATION
        // =====================================================================
        
        let conductor;
        
        window.addEventListener('load', () => {
            conductor = new UltimateAIBandConductor();
        });
        
        function startBand() {
            conductor.startBand();
        }
        
        function stopBand() {
            conductor.stopBand();
        }
        
        function testBand() {
            conductor.testBand();
        }
        
        function selectGenre(genre) {
            document.querySelectorAll('.genre-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            conductor.setGenre(genre);
        }
        
        function toggleMute(instrument) {
            conductor.toggleMute(instrument);
        }
        
        // Volume controls
        window.addEventListener('load', () => {
            for (let inst of ['drums', 'bass', 'guitar', 'piano', 'strings', 'pads']) {
                const slider = document.getElementById(`${inst}-vol`);
                if (slider) {
                    slider.addEventListener('input', (e) => {
                        conductor.setVolume(inst, e.target.value);
                    });
                }
            }
        });
    </script>
</body>
</html>