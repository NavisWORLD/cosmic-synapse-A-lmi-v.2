<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Band Conductor - Professional Studio Quality</title>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #0a0e27, #1a1f3a, #2d1b3d);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            padding: 40px 20px;
            background: rgba(255,255,255,0.05);
            border-radius: 20px;
            margin-bottom: 30px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        
        .header h1 {
            font-size: 3.5em;
            margin-bottom: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 3s infinite;
        }
        
        @keyframes shimmer {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2); }
        }
        
        .subtitle {
            font-size: 1.4em;
            margin: 10px 0;
            opacity: 0.95;
        }
        
        .tagline {
            font-size: 1em;
            opacity: 0.7;
            margin-top: 10px;
        }
        
        .main-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-panel {
            background: rgba(255,255,255,0.08);
            padding: 25px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .control-panel h3 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.3em;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-box {
            background: rgba(0,0,0,0.4);
            padding: 20px;
            border-radius: 12px;
            margin: 15px 0;
            border: 1px solid rgba(102, 126, 234, 0.3);
        }
        
        .metric-display {
            display: flex;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .metric-label {
            color: #a78bfa;
            font-weight: 600;
        }
        
        .metric-value {
            color: #4ade80;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            font-weight: 700;
        }
        
        .big-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 20px 40px;
            border-radius: 12px;
            font-size: 1.3em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            margin: 10px 0;
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }
        
        .big-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 30px rgba(102, 126, 234, 0.7);
        }
        
        .big-button:active {
            transform: translateY(0);
        }
        
        .big-button.stop {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            box-shadow: 0 6px 20px rgba(245, 87, 108, 0.5);
        }
        
        .big-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .instrument-mixer {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .instrument-channel {
            background: rgba(0,0,0,0.4);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s;
        }
        
        .instrument-channel.active {
            border-color: #4ade80;
            box-shadow: 0 0 20px rgba(74, 222, 128, 0.3);
        }
        
        .instrument-icon {
            font-size: 2em;
            margin-bottom: 8px;
        }
        
        .instrument-name {
            font-weight: 600;
            margin-bottom: 10px;
            color: #a78bfa;
        }
        
        .volume-slider {
            width: 100%;
            margin: 10px 0;
        }
        
        .mute-button {
            background: rgba(102, 126, 234, 0.3);
            border: 1px solid rgba(102, 126, 234, 0.5);
            color: white;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s;
        }
        
        .mute-button.muted {
            background: rgba(245, 87, 108, 0.5);
            border-color: #f5576c;
        }
        
        .visualizer-section {
            background: rgba(0,0,0,0.6);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        canvas {
            width: 100%;
            border-radius: 10px;
            background: linear-gradient(180deg, #0a0a0a 0%, #1a1a2e 100%);
        }
        
        .log-panel {
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 15px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
        }
        
        .log-entry {
            padding: 8px;
            margin: 5px 0;
            border-left: 3px solid #667eea;
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        .log-entry.info { color: #60a5fa; border-left-color: #60a5fa; }
        .log-entry.success { color: #4ade80; border-left-color: #4ade80; }
        .log-entry.warning { color: #fbbf24; border-left-color: #fbbf24; }
        .log-entry.music { color: #a78bfa; border-left-color: #a78bfa; }
        .log-entry.error { color: #f87171; border-left-color: #f87171; }
        
        .genre-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .genre-button {
            background: rgba(102, 126, 234, 0.2);
            border: 2px solid rgba(102, 126, 234, 0.4);
            color: white;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            text-align: center;
        }
        
        .genre-button:hover {
            background: rgba(102, 126, 234, 0.4);
            transform: scale(1.05);
        }
        
        .genre-button.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-color: #4ade80;
            box-shadow: 0 0 15px rgba(74, 222, 128, 0.5);
        }
        
        @media (max-width: 768px) {
            .header h1 { font-size: 2em; }
            .main-controls { grid-template-columns: 1fr; }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>üé∏ AI Band Conductor ü•Å</h1>
            <p class="subtitle">Professional Studio-Quality Real-Time Accompaniment</p>
            <p class="tagline">Your Personal AI Band That Listens and Jams With You</p>
        </div>
        
        <div class="main-controls">
            <!-- Analysis Display -->
            <div class="control-panel">
                <h3>üéµ Musical Analysis</h3>
                <div class="status-box">
                    <div class="metric-display">
                        <span class="metric-label">Your Pitch:</span>
                        <span class="metric-value" id="userPitch">-- Hz</span>
                    </div>
                    <div class="metric-display">
                        <span class="metric-label">Detected Note:</span>
                        <span class="metric-value" id="detectedNote">--</span>
                    </div>
                    <div class="metric-display">
                        <span class="metric-label">Key:</span>
                        <span class="metric-value" id="detectedKey">C Major</span>
                    </div>
                    <div class="metric-display">
                        <span class="metric-label">Tempo:</span>
                        <span class="metric-value" id="detectedTempo">120 BPM</span>
                    </div>
                    <div class="metric-display">
                        <span class="metric-label">Energy:</span>
                        <span class="metric-value" id="energyLevel">Medium</span>
                    </div>
                </div>
            </div>
            
            <!-- Main Controls -->
            <div class="control-panel">
                <h3>üéõÔ∏è Band Controls</h3>
                <button class="big-button" id="startButton" onclick="startBand()">
                    üé§ Start Jamming!
                </button>
                <button class="big-button stop" id="stopButton" onclick="stopBand()" disabled>
                    ‚èπ Stop Band
                </button>
                <button class="big-button" style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);" onclick="testBand()">
                    üîä Test Band
                </button>
            </div>
            
            <!-- Genre Selection -->
            <div class="control-panel">
                <h3>üé® Genre & Style</h3>
                <div class="genre-selector">
                    <div class="genre-button active" data-genre="rock" onclick="selectGenre('rock')">
                        üé∏ Rock
                    </div>
                    <div class="genre-button" data-genre="jazz" onclick="selectGenre('jazz')">
                        üé∫ Jazz
                    </div>
                    <div class="genre-button" data-genre="funk" onclick="selectGenre('funk')">
                        üï∫ Funk
                    </div>
                    <div class="genre-button" data-genre="blues" onclick="selectGenre('blues')">
                        üéπ Blues
                    </div>
                    <div class="genre-button" data-genre="pop" onclick="selectGenre('pop')">
                        ‚≠ê Pop
                    </div>
                    <div class="genre-button" data-genre="latin" onclick="selectGenre('latin')">
                        üå¥ Latin
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Instrument Mixer -->
        <div class="control-panel">
            <h3>üéöÔ∏è Instrument Mixer</h3>
            <div class="instrument-mixer">
                <div class="instrument-channel" id="drums-channel">
                    <div class="instrument-icon">ü•Å</div>
                    <div class="instrument-name">Drums</div>
                    <input type="range" class="volume-slider" id="drums-volume" min="0" max="100" value="80">
                    <button class="mute-button" onclick="toggleMute('drums')">Mute</button>
                </div>
                
                <div class="instrument-channel" id="bass-channel">
                    <div class="instrument-icon">üé∏</div>
                    <div class="instrument-name">Bass</div>
                    <input type="range" class="volume-slider" id="bass-volume" min="0" max="100" value="70">
                    <button class="mute-button" onclick="toggleMute('bass')">Mute</button>
                </div>
                
                <div class="instrument-channel" id="guitar-channel">
                    <div class="instrument-icon">üé∏</div>
                    <div class="instrument-name">Guitar</div>
                    <input type="range" class="volume-slider" id="guitar-volume" min="0" max="100" value="60">
                    <button class="mute-button" onclick="toggleMute('guitar')">Mute</button>
                </div>
                
                <div class="instrument-channel" id="piano-channel">
                    <div class="instrument-icon">üéπ</div>
                    <div class="instrument-name">Piano</div>
                    <input type="range" class="volume-slider" id="piano-volume" min="0" max="100" value="65">
                    <button class="mute-button" onclick="toggleMute('piano')">Mute</button>
                </div>
                
                <div class="instrument-channel" id="strings-channel">
                    <div class="instrument-icon">üéª</div>
                    <div class="instrument-name">Strings</div>
                    <input type="range" class="volume-slider" id="strings-volume" min="0" max="100" value="50">
                    <button class="mute-button" onclick="toggleMute('strings')">Mute</button>
                </div>
            </div>
        </div>
        
        <!-- Visualizers -->
        <div class="visualizer-section">
            <h3 style="margin-bottom: 15px;">üìä Spectrum Analyzer</h3>
            <canvas id="spectrumCanvas" height="200"></canvas>
        </div>
        
        <div class="visualizer-section">
            <h3 style="margin-bottom: 15px;">„Ä∞Ô∏è Waveform Display</h3>
            <canvas id="waveformCanvas" height="200"></canvas>
        </div>
        
        <!-- Activity Log -->
        <div class="control-panel">
            <h3>üìù Band Activity Log</h3>
            <div class="log-panel" id="logPanel">
                <div class="log-entry info">[System] AI Band Conductor v3.0 initialized</div>
                <div class="log-entry info">[System] Professional studio instrumentation loaded</div>
                <div class="log-entry success">[System] Ready to jam! Click "Start Jamming" to begin</div>
            </div>
        </div>
    </div>
    
    <script>
        // =====================================================================
        // AI BAND CONDUCTOR v3.0 - COMPLETE PROFESSIONAL IMPLEMENTATION
        // Real-time musical accompaniment with full instrumentation
        // Author: Cory Shane Davis
        // Date: October 28, 2025
        // =====================================================================
        
        class AIBandConductor {
            constructor() {
                this.audioContext = null;
                this.analyzer = null;
                this.microphone = null;
                this.isActive = false;
                
                // Musical state
                this.currentPitch = null;
                this.currentNote = null;
                this.currentKey = 'C';
                this.currentMode = 'major';
                this.currentTempo = 120;
                this.currentGenre = 'rock';
                this.energyLevel = 0.5;
                
                // Pitch history for key detection
                this.pitchHistory = [];
                this.maxPitchHistory = 50;
                
                // Instruments
                this.instruments = {
                    drums: { gain: null, enabled: true, volume: 0.8, active: false },
                    bass: { gain: null, enabled: true, volume: 0.7, active: false },
                    guitar: { gain: null, enabled: true, volume: 0.6, active: false },
                    piano: { gain: null, enabled: true, volume: 0.65, active: false },
                    strings: { gain: null, enabled: true, volume: 0.5, active: false }
                };
                
                // Master effects
                this.masterCompressor = null;
                this.masterGain = null;
                
                // Timing
                this.lastDrumBeat = 0;
                this.lastBassNote = 0;
                this.beatInterval = 500; // ms
                
                // Note names
                this.noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                
                // Initialize
                this.initAudio();
            }
            
            async initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Create analyzer
                    this.analyzer = this.audioContext.createAnalyser();
                    this.analyzer.fftSize = 4096;
                    this.analyzer.smoothingTimeConstant = 0.8;
                    
                    // Create master chain
                    this.masterCompressor = this.audioContext.createDynamicsCompressor();
                    this.masterCompressor.threshold.value = -24;
                    this.masterCompressor.knee.value = 30;
                    this.masterCompressor.ratio.value = 12;
                    this.masterCompressor.attack.value = 0.003;
                    this.masterCompressor.release.value = 0.25;
                    
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.gain.value = 0.7;
                    
                    this.masterCompressor.connect(this.masterGain);
                    this.masterGain.connect(this.audioContext.destination);
                    
                    // Initialize instrument gain nodes
                    for (let inst in this.instruments) {
                        this.instruments[inst].gain = this.audioContext.createGain();
                        this.instruments[inst].gain.gain.value = this.instruments[inst].volume;
                        this.instruments[inst].gain.connect(this.masterCompressor);
                    }
                    
                    this.log('üéµ Audio system initialized successfully', 'success');
                    
                } catch (error) {
                    this.log(`‚ùå Audio init failed: ${error.message}`, 'error');
                }
            }
            
            async startBand() {
                if (this.isActive) return;
                
                try {
                    // Get microphone
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        } 
                    });
                    
                    this.microphone = this.audioContext.createMediaStreamSource(stream);
                    this.microphone.connect(this.analyzer);
                    
                    this.isActive = true;
                    this.log('üé§ Microphone connected - listening to you!', 'success');
                    this.log(`üé∏ Band is ready in ${this.currentGenre.toUpperCase()} style`, 'music');
                    
                    // Update UI
                    document.getElementById('startButton').disabled = true;
                    document.getElementById('stopButton').disabled = false;
                    
                    // Start main loop
                    this.mainLoop();
                    
                    // Start visualization
                    this.visualizationLoop();
                    
                } catch (error) {
                    this.log(`‚ùå Failed to start: ${error.message}`, 'error');
                }
            }
            
            mainLoop() {
                if (!this.isActive) return;
                
                // Get audio data
                const bufferLength = this.analyzer.fftSize;
                const timeDomainData = new Float32Array(bufferLength);
                this.analyzer.getFloatTimeDomainData(timeDomainData);
                
                // Detect pitch
                this.currentPitch = this.detectPitch(timeDomainData);
                
                if (this.currentPitch) {
                    this.currentNote = this.frequencyToNote(this.currentPitch);
                    this.pitchHistory.push(this.currentPitch);
                    
                    if (this.pitchHistory.length > this.maxPitchHistory) {
                        this.pitchHistory.shift();
                    }
                    
                    // Update UI
                    document.getElementById('userPitch').textContent = `${this.currentPitch.toFixed(1)} Hz`;
                    document.getElementById('detectedNote').textContent = this.currentNote;
                }
                
                // Detect key (every 2 seconds)
                if (Math.random() < 0.02 && this.pitchHistory.length > 10) {
                    this.detectKey();
                }
                
                // Calculate energy
                this.energyLevel = this.calculateEnergy(timeDomainData);
                const energyText = this.energyLevel < 0.3 ? 'Low' : this.energyLevel < 0.6 ? 'Medium' : 'High';
                document.getElementById('energyLevel').textContent = energyText;
                
                // Generate accompaniment
                const now = Date.now();
                this.beatInterval = (60000 / this.currentTempo); // ms per beat
                
                // Drums - play on beat
                if (now - this.lastDrumBeat >= this.beatInterval) {
                    this.playDrums();
                    this.lastDrumBeat = now;
                }
                
                // Bass - play with drums
                if (this.currentPitch && now - this.lastBassNote >= this.beatInterval) {
                    this.playBass();
                    this.lastBassNote = now;
                }
                
                // Chords - piano/guitar (every 2 beats)
                if (Math.random() < 0.5 / 60) { // Roughly every 2 seconds
                    this.playChord();
                }
                
                // Continue loop
                setTimeout(() => this.mainLoop(), 50);
            }
            
            detectPitch(buffer) {
                // Autocorrelation method
                const SIZE = buffer.length;
                const MAX_SAMPLES = Math.floor(SIZE / 2);
                let best_offset = -1;
                let best_correlation = 0;
                let rms = 0;
                
                // Calculate RMS
                for (let i = 0; i < SIZE; i++) {
                    rms += buffer[i] * buffer[i];
                }
                rms = Math.sqrt(rms / SIZE);
                
                // Not enough signal
                if (rms < 0.01) return null;
                
                // Autocorrelation
                let lastCorrelation = 1;
                for (let offset = 1; offset < MAX_SAMPLES; offset++) {
                    let correlation = 0;
                    
                    for (let i = 0; i < MAX_SAMPLES; i++) {
                        correlation += Math.abs(buffer[i] - buffer[i + offset]);
                    }
                    
                    correlation = 1 - (correlation / MAX_SAMPLES);
                    
                    if (correlation > 0.9 && correlation > lastCorrelation) {
                        const foundGoodCorrelation = correlation > best_correlation;
                        const foundOctave = best_offset > 0 && Math.abs(offset - 2 * best_offset) < 2;
                        
                        if (foundGoodCorrelation && !foundOctave) {
                            best_correlation = correlation;
                            best_offset = offset;
                        }
                    }
                    
                    lastCorrelation = correlation;
                }
                
                if (best_correlation > 0.01 && best_offset > 0) {
                    const frequency = this.audioContext.sampleRate / best_offset;
                    
                    // Filter to musical range
                    if (frequency >= 50 && frequency <= 1000) {
                        return frequency;
                    }
                }
                
                return null;
            }
            
            frequencyToNote(frequency) {
                const noteNum = 12 * (Math.log(frequency / 440) / Math.log(2));
                const noteIndex = Math.round(noteNum) + 69;
                const note = this.noteNames[noteIndex % 12];
                const octave = Math.floor(noteIndex / 12) - 1;
                return `${note}${octave}`;
            }
            
            noteToFrequency(note, octave) {
                const noteIndex = this.noteNames.indexOf(note);
                const midiNote = (octave + 1) * 12 + noteIndex;
                return 440 * Math.pow(2, (midiNote - 69) / 12);
            }
            
            detectKey() {
                // Simplified key detection
                // Count pitch class occurrences
                const pitchClasses = new Array(12).fill(0);
                
                for (let freq of this.pitchHistory) {
                    const noteNum = Math.round(12 * (Math.log(freq / 440) / Math.log(2))) + 69;
                    const pitchClass = noteNum % 12;
                    pitchClasses[pitchClass]++;
                }
                
                // Find most common pitch class
                let maxCount = 0;
                let tonic = 0;
                
                for (let i = 0; i < 12; i++) {
                    if (pitchClasses[i] > maxCount) {
                        maxCount = pitchClasses[i];
                        tonic = i;
                    }
                }
                
                this.currentKey = this.noteNames[tonic];
                
                // Update UI
                document.getElementById('detectedKey').textContent = `${this.currentKey} ${this.currentMode}`;
                
                this.log(`üéµ Key detected: ${this.currentKey} ${this.currentMode}`, 'music');
            }
            
            calculateEnergy(buffer) {
                let sum = 0;
                for (let i = 0; i < buffer.length; i++) {
                    sum += buffer[i] * buffer[i];
                }
                return Math.sqrt(sum / buffer.length);
            }
            
            // ================ INSTRUMENTS ================
            
            playDrums() {
                if (!this.instruments.drums.enabled) return;
                
                const patterns = {
                    'rock': () => {
                        this.playKick();
                        this.playHiHat();
                        setTimeout(() => this.playSnare(), this.beatInterval / 2);
                        setTimeout(() => this.playHiHat(), this.beatInterval / 2);
                    },
                    'funk': () => {
                        this.playKick();
                        setTimeout(() => this.playHiHat(), this.beatInterval / 4);
                        setTimeout(() => this.playSnare(), this.beatInterval / 2);
                        setTimeout(() => this.playKick(), this.beatInterval * 3/4);
                    },
                    'jazz': () => {
                        this.playRide();
                        setTimeout(() => this.playSnare(0.3), this.beatInterval / 3);
                        setTimeout(() => this.playKick(0.4), this.beatInterval * 2/3);
                    },
                    'pop': () => {
                        this.playKick();
                        this.playHiHat();
                        setTimeout(() => this.playSnare(), this.beatInterval / 2);
                        setTimeout(() => this.playHiHat(), this.beatInterval / 2);
                    }
                };
                
                const pattern = patterns[this.currentGenre] || patterns['rock'];
                pattern();
                
                this.instruments.drums.active = true;
                document.getElementById('drums-channel').classList.add('active');
                setTimeout(() => {
                    this.instruments.drums.active = false;
                    document.getElementById('drums-channel').classList.remove('active');
                }, 100);
            }
            
            playKick(velocity = 0.8) {
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                const now = this.audioContext.currentTime;
                
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
                
                gain.gain.setValueAtTime(velocity, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                
                osc.connect(gain);
                gain.connect(this.instruments.drums.gain);
                
                osc.start(now);
                osc.stop(now + 0.5);
            }
            
            playSnare(velocity = 0.6) {
                const bufferSize = this.audioContext.sampleRate * 0.2;
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const output = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize / 5));
                }
                
                const noise = this.audioContext.createBufferSource();
                noise.buffer = buffer;
                
                const filter = this.audioContext.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 1000;
                
                const gain = this.audioContext.createGain();
                gain.gain.value = velocity;
                
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.instruments.drums.gain);
                
                noise.start();
            }
            
            playHiHat(velocity = 0.3) {
                const bufferSize = this.audioContext.sampleRate * 0.05;
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const output = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize / 10));
                }
                
                const noise = this.audioContext.createBufferSource();
                noise.buffer = buffer;
                
                const filter = this.audioContext.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 7000;
                
                const gain = this.audioContext.createGain();
                gain.gain.value = velocity;
                
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.instruments.drums.gain);
                
                noise.start();
            }
            
            playRide(velocity = 0.25) {
                const osc1 = this.audioContext.createOscillator();
                const osc2 = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                osc1.frequency.value = 3000;
                osc2.frequency.value = 5000;
                
                const now = this.audioContext.currentTime;
                gain.gain.setValueAtTime(velocity, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                
                osc1.connect(gain);
                osc2.connect(gain);
                gain.connect(this.instruments.drums.gain);
                
                osc1.start(now);
                osc2.start(now);
                osc1.stop(now + 0.3);
                osc2.stop(now + 0.3);
            }
            
            playBass() {
                if (!this.instruments.bass.enabled || !this.currentPitch) return;
                
                // Find root note (octave below user)
                let bassFreq = this.currentPitch;
                while (bassFreq > 100) bassFreq /= 2;
                
                const osc = this.audioContext.createOscillator();
                const filter = this.audioContext.createBiquadFilter();
                const gain = this.audioContext.createGain();
                
                osc.type = 'sawtooth';
                osc.frequency.value = bassFreq;
                
                filter.type = 'lowpass';
                filter.frequency.value = 800;
                filter.Q.value = 2;
                
                const now = this.audioContext.currentTime;
                const duration = this.beatInterval / 1000;
                
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.4, now + 0.05);
                gain.gain.setValueAtTime(0.4, now + duration - 0.1);
                gain.gain.linearRampToValueAtTime(0, now + duration);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.instruments.bass.gain);
                
                osc.start(now);
                osc.stop(now + duration);
                
                this.instruments.bass.active = true;
                document.getElementById('bass-channel').classList.add('active');
                setTimeout(() => {
                    this.instruments.bass.active = false;
                    document.getElementById('bass-channel').classList.remove('active');
                }, 200);
            }
            
            playChord() {
                if (!this.currentPitch) return;
                
                // Build chord from user's pitch
                const root = this.currentPitch;
                const third = root * Math.pow(2, 4/12); // Major third
                const fifth = root * Math.pow(2, 7/12); // Perfect fifth
                
                const chordNotes = [root, third, fifth];
                
                // Play on piano and guitar
                if (this.instruments.piano.enabled) {
                    this.playPianoChord(chordNotes);
                }
                
                if (this.instruments.guitar.enabled) {
                    this.playGuitarChord(chordNotes);
                }
            }
            
            playPianoChord(notes) {
                notes.forEach((freq, i) => {
                    setTimeout(() => this.playPianoNote(freq), i * 30); // Slight strum
                });
                
                this.instruments.piano.active = true;
                document.getElementById('piano-channel').classList.add('active');
                setTimeout(() => {
                    this.instruments.piano.active = false;
                    document.getElementById('piano-channel').classList.remove('active');
                }, 300);
            }
            
            playPianoNote(frequency, velocity = 0.3) {
                // FM synthesis for piano
                const carrier = this.audioContext.createOscillator();
                const modulator = this.audioContext.createOscillator();
                const modGain = this.audioContext.createGain();
                const gain = this.audioContext.createGain();
                
                carrier.frequency.value = frequency;
                modulator.frequency.value = frequency * 2;
                modGain.gain.value = frequency * 2;
                
                const now = this.audioContext.currentTime;
                
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(velocity, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(velocity * 0.3, now + 0.2);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 1.5);
                
                modulator.connect(modGain);
                modGain.connect(carrier.frequency);
                carrier.connect(gain);
                gain.connect(this.instruments.piano.gain);
                
                carrier.start(now);
                modulator.start(now);
                carrier.stop(now + 1.5);
                modulator.stop(now + 1.5);
            }
            
            playGuitarChord(notes) {
                notes.forEach((freq, i) => {
                    setTimeout(() => this.playGuitarString(freq), i * 20);
                });
                
                this.instruments.guitar.active = true;
                document.getElementById('guitar-channel').classList.add('active');
                setTimeout(() => {
                    this.instruments.guitar.active = false;
                    document.getElementById('guitar-channel').classList.remove('active');
                }, 300);
            }
            
            playGuitarString(frequency) {
                // Karplus-Strong algorithm
                const sampleRate = this.audioContext.sampleRate;
                const duration = 2.0;
                const delayLength = Math.round(sampleRate / frequency);
                
                const bufferSize = sampleRate * duration;
                const buffer = this.audioContext.createBuffer(1, bufferSize, sampleRate);
                const output = buffer.getChannelData(0);
                
                // Noise burst
                for (let i = 0; i < delayLength; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                
                // Feedback loop
                for (let i = delayLength; i < bufferSize; i++) {
                    output[i] = 0.996 * 0.5 * (output[i - delayLength] + output[i - delayLength + 1]);
                }
                
                const source = this.audioContext.createBufferSource();
                source.buffer = buffer;
                
                const gain = this.audioContext.createGain();
                gain.gain.value = 0.2;
                
                source.connect(gain);
                gain.connect(this.instruments.guitar.gain);
                
                source.start();
            }
            
            // ================ VISUALIZATION ================
            
            visualizationLoop() {
                if (!this.isActive) return;
                
                this.drawSpectrum();
                this.drawWaveform();
                
                requestAnimationFrame(() => this.visualizationLoop());
            }
            
            drawSpectrum() {
                const canvas = document.getElementById('spectrumCanvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = canvas.offsetWidth;
                canvas.height = 200;
                
                const bufferLength = this.analyzer.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                this.analyzer.getByteFrequencyData(dataArray);
                
                ctx.fillStyle = 'rgb(10, 10, 10)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const barWidth = (canvas.width / bufferLength) * 2.5;
                let x = 0;
                
                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = (dataArray[i] / 255) * canvas.height * 0.9;
                    
                    const hue = (i / bufferLength) * 280 + 220;
                    const lightness = 35 + (dataArray[i] / 255) * 35;
                    ctx.fillStyle = `hsl(${hue}, 100%, ${lightness}%)`;
                    
                    ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                    x += barWidth + 1;
                }
                
                // Draw pitch marker
                if (this.currentPitch) {
                    const nyquist = this.audioContext.sampleRate / 2;
                    const freqIndex = (this.currentPitch / nyquist) * bufferLength;
                    const markerX = (freqIndex / bufferLength) * canvas.width;
                    
                    ctx.strokeStyle = '#4ade80';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(markerX, 0);
                    ctx.lineTo(markerX, canvas.height);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    ctx.fillStyle = '#4ade80';
                    ctx.font = 'bold 14px monospace';
                    ctx.fillText(`${this.currentNote} (${this.currentPitch.toFixed(1)}Hz)`, markerX + 5, 20);
                }
            }
            
            drawWaveform() {
                const canvas = document.getElementById('waveformCanvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = canvas.offsetWidth;
                canvas.height = 200;
                
                const bufferLength = this.analyzer.fftSize;
                const dataArray = new Uint8Array(bufferLength);
                this.analyzer.getByteTimeDomainData(dataArray);
                
                ctx.fillStyle = 'rgb(10, 10, 10)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.lineWidth = 3;
                ctx.strokeStyle = 'rgb(102, 126, 234)';
                ctx.beginPath();
                
                const sliceWidth = canvas.width / bufferLength;
                let x = 0;
                
                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * canvas.height / 2;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                    
                    x += sliceWidth;
                }
                
                ctx.stroke();
                
                // Center line
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, canvas.height / 2);
                ctx.lineTo(canvas.width, canvas.height / 2);
                ctx.stroke();
            }
            
            // ================ CONTROLS ================
            
            stopBand() {
                this.isActive = false;
                
                if (this.microphone) {
                    this.microphone.disconnect();
                    this.microphone = null;
                }
                
                this.log('‚èπ Band stopped', 'warning');
                
                document.getElementById('startButton').disabled = false;
                document.getElementById('stopButton').disabled = true;
                
                // Clear active states
                for (let inst in this.instruments) {
                    document.getElementById(`${inst}-channel`).classList.remove('active');
                }
            }
            
            testBand() {
                this.log('üîä Testing band...', 'info');
                
                // Test all instruments
                this.playKick();
                setTimeout(() => this.playSnare(), 250);
                setTimeout(() => this.playHiHat(), 500);
                
                const testFreq = 440; // A4
                setTimeout(() => this.playBass(), 750);
                
                this.currentPitch = testFreq;
                setTimeout(() => this.playChord(), 1000);
                
                this.log('‚úÖ Band test complete!', 'success');
            }
            
            setGenre(genre) {
                this.currentGenre = genre;
                this.log(`üé® Genre changed to: ${genre.toUpperCase()}`, 'music');
                
                // Adjust tempo by genre
                const tempos = {
                    'rock': 120,
                    'jazz': 140,
                    'funk': 110,
                    'blues': 90,
                    'pop': 128,
                    'latin': 100
                };
                
                this.currentTempo = tempos[genre] || 120;
                document.getElementById('detectedTempo').textContent = `${this.currentTempo} BPM`;
            }
            
            toggleMute(instrument) {
                this.instruments[instrument].enabled = !this.instruments[instrument].enabled;
                
                const button = event.target;
                button.classList.toggle('muted');
                button.textContent = this.instruments[instrument].enabled ? 'Mute' : 'Unmuted';
                
                const status = this.instruments[instrument].enabled ? 'unmuted' : 'muted';
                this.log(`üîá ${instrument.toUpperCase()} ${status}`, 'info');
            }
            
            setVolume(instrument, value) {
                this.instruments[instrument].volume = value / 100;
                if (this.instruments[instrument].gain) {
                    this.instruments[instrument].gain.gain.value = this.instruments[instrument].volume;
                }
            }
            
            log(message, type = 'info') {
                const logPanel = document.getElementById('logPanel');
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                
                logPanel.appendChild(entry);
                logPanel.scrollTop = logPanel.scrollHeight;
                
                if (logPanel.children.length > 100) {
                    logPanel.removeChild(logPanel.firstChild);
                }
            }
        }
        
        // =====================================================================
        // GLOBAL INSTANCE AND CONTROLS
        // =====================================================================
        
        let conductor;
        
        window.addEventListener('load', () => {
            conductor = new AIBandConductor();
        });
        
        function startBand() {
            conductor.startBand();
        }
        
        function stopBand() {
            conductor.stopBand();
        }
        
        function testBand() {
            conductor.testBand();
        }
        
        function selectGenre(genre) {
            // Update UI
            document.querySelectorAll('.genre-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Update conductor
            conductor.setGenre(genre);
        }
        
        function toggleMute(instrument) {
            conductor.toggleMute(instrument);
        }
        
        // Volume slider listeners
        window.addEventListener('load', () => {
            for (let inst of ['drums', 'bass', 'guitar', 'piano', 'strings']) {
                const slider = document.getElementById(`${inst}-volume`);
                slider.addEventListener('input', (e) => {
                    conductor.setVolume(inst, e.target.value);
                });
            }
        });
    </script>
</body>
</html>